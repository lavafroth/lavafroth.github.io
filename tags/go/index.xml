<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on lavafroth</title><link>https://lavafroth.is-a.dev/tags/go/</link><description>Recent content in Go on lavafroth</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Fri, 13 Jun 2025 08:39:58 +0530</lastBuildDate><atom:link href="https://lavafroth.is-a.dev/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Easy grep to detect stripped Go binaries</title><link>https://lavafroth.is-a.dev/post/detecting-stripped-go-binaries/</link><pubDate>Fri, 13 Jun 2025 08:39:58 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/detecting-stripped-go-binaries/</guid><description>&lt;p&gt;A couple of days ago when I was reading the &lt;a href="https://tip.golang.org/doc/gc-guide"&gt;guide to the Go garbage collector&lt;/a&gt;, I came across the following excerpt:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When all else fails, the Go GC provides a few different specific traces that provide much deeper insights into GC behavior. These traces are always printed directly to STDERR, one line per GC cycle, and are configured through the GODEBUG environment variable that all Go programs recognize.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;An environment variable that all Go programs recognize, you say? I had a sneaking suspicion that I could just perform a string search for this term, given all Go programs would need to look for this environment variable definition. This way, we could guess if a binary was written in Go.&lt;/p&gt;</description></item><item><title>2 Afternoons, 2 Languages, 2 TUIs</title><link>https://lavafroth.is-a.dev/post/2-afternoons-2-languages-2-tuis/</link><pubDate>Thu, 23 May 2024 18:37:47 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/2-afternoons-2-languages-2-tuis/</guid><description>&lt;p&gt;Yesterday I created a tool in Golang to help me render my animations a little
faster. Although the alterior reason was to check my Golang proficiency, today
I rewrote it in Rust and I was blown away by the differences in the final
products.&lt;/p&gt;
&lt;p&gt;When I&amp;rsquo;m rendering animations for a YouTube video, the general development
iteration comprises me creating or modifying a file, switching to a different
terminal pane and manually issuing a &lt;em&gt;manim&lt;/em&gt; command for the respective file to
render and play the animation. My goal was to automate the last two processes,
switching terminal panes and manually issuing a command. The idea is to have a
tool running in the background that listens for filesystem events, like when a
file gets created or modified, and if the file happens to contain an animation,
renders it. On linux systems, it&amp;rsquo;s mostly a bunch of bindings to &lt;code&gt;inotify&lt;/code&gt; but I
have used platform agnostic libraries for both the languages.&lt;/p&gt;</description></item></channel></rss>