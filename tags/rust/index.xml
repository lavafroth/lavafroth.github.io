<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on lavafroth</title><link>https://lavafroth.is-a.dev/tags/rust/</link><description>Recent content in Rust on lavafroth</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 02 Nov 2025 19:08:46 +0530</lastBuildDate><atom:link href="https://lavafroth.is-a.dev/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Algebraic Python Enums</title><link>https://lavafroth.is-a.dev/post/algebraic-python-enums/</link><pubDate>Sun, 02 Nov 2025 19:08:46 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/algebraic-python-enums/</guid><description>&lt;p&gt;As much as I like rust for its ergonomic features, University has forced me to use Python for the past couple of months, especially because of the hype for machine learning and data science.&lt;/p&gt;
&lt;p&gt;One of the biggest things that I missed from the rust experience was enumerable data types whose variants can wrap around different datatypes.&lt;/p&gt;
&lt;p&gt;Fortunately, since Python 3.8, creating structs has been a breeze using the dataclass decorator. There&amp;rsquo;s even support for structural match expressions, like in rust, in recent versions of &lt;a href="https://peps.python.org/pep-0636/"&gt;Python&lt;/a&gt;.&lt;/p&gt;</description></item><item><title>Wrapping up GSoC 2024</title><link>https://lavafroth.is-a.dev/post/the-gsoc-grand-finale/</link><pubDate>Sat, 24 Aug 2024 10:28:50 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/the-gsoc-grand-finale/</guid><description>&lt;h1 id="overview"&gt;Overview&lt;/h1&gt;
&lt;p&gt;Hello and welcome to the final GSoC post for 2024! My task was to formalize the SWHKD parser using context-free EBNF notation. This post is to serve as a birdseye view of what
I have developed over this summer.&lt;/p&gt;
&lt;h1 id="report"&gt;Report&lt;/h1&gt;
&lt;h2 id="architecting-the-parser"&gt;Architecting the parser&lt;/h2&gt;
&lt;p&gt;I started out with the scaffolding of the parser in an extended Backus-Naur form garmmar template
in a separate repository called &lt;a href="https://github.com/waycrate/sweet"&gt;SWEET&lt;/a&gt; using a Rust framework
called &lt;a href="https://pest.rs"&gt;pest.rs&lt;/a&gt;. Quite a lot of time was
spent in modelling the architecture of the syntax tree for our domain specific language.&lt;/p&gt;</description></item><item><title>Polishing and Bugfix Week</title><link>https://lavafroth.is-a.dev/post/polishing-and-bugfix-week/</link><pubDate>Mon, 29 Jul 2024 13:46:41 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/polishing-and-bugfix-week/</guid><description>&lt;p&gt;Hello and welcome to the last instalment in the series where we build a parser
for a domain specific langauge in Rust. Please go through the previous articles
since this article assumes you are aware of such contextual details.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s start with the bugfixes.&lt;/p&gt;
&lt;h1 id="eagerly-removing-unbinds"&gt;Eagerly removing unbinds&lt;/h1&gt;
&lt;p&gt;While going through the tests, I figured that
the prior parser eagerly parses unbinds and removes said keystroke combinations
from our binding set. Unlike the previous iteration, our iteration had unbinds
as a separate set which deferred the task of the removing the set intersection
to the upstream crate instead.&lt;/p&gt;</description></item><item><title>Humans Suck at Command Sanitization</title><link>https://lavafroth.is-a.dev/post/humans-suck-at-command-sanitization/</link><pubDate>Wed, 17 Jul 2024 07:55:34 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/humans-suck-at-command-sanitization/</guid><description>&lt;p&gt;Hello and welcome to the eighth instalment in the series where we build a parser
for a domain specific language in Rust. I’d highly recommend going through the
previous articles to make sense of what we’ll talk about today.&lt;/p&gt;
&lt;p&gt;Previously, we had built the scaffolding for modes to bind shortcuts to. Today,
we&amp;rsquo;ll create the mechanism to invoke commands in the contexts of the modes that
can be built.&lt;/p&gt;
&lt;p&gt;Now, SWHKD has a clever way to enter (and escape) mode contexts with inside commands
by chaining subcommands and mode instructions with double ampersands. Consider the following example:&lt;/p&gt;</description></item><item><title>Preventing Infinite Recursions From Eating Your Lunch</title><link>https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/</link><pubDate>Thu, 04 Jul 2024 09:57:01 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/</guid><description>&lt;p&gt;Hello and welcome to the eighth instalment in the series where we build a
parser for a domain specific language in Rust. I&amp;rsquo;d highly recommend
going through the previous articles to make sense of what we’ll talk about today.&lt;/p&gt;
&lt;p&gt;After a bit of back and forth with my mentor, we landed on moving the logic that imports
other config files into the parser crate itself. Config files can reference other modules
using import statements of the following form:&lt;/p&gt;</description></item><item><title>Test Driven Development - The Pinnacle of Engineering</title><link>https://lavafroth.is-a.dev/post/test-driven-development-the-pinnacle-of-engineering/</link><pubDate>Mon, 24 Jun 2024 08:45:49 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/test-driven-development-the-pinnacle-of-engineering/</guid><description>&lt;p&gt;Hello and welcome to the seventh instalment in the series where we build a
parser for a domain specific language in Rust. I would highly recommend you to
go through the previous articles to make sense of what we’ll talk about today.&lt;/p&gt;
&lt;h2 id="tying-loose-ends"&gt;Tying loose ends&lt;/h2&gt;
&lt;p&gt;Up until the last post, we had covered quite some ground, from building
elementary expressions to the penultimate levels of abstraction for macroscopic
expressions.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s begin today&amp;rsquo;s conversation by finishing off where we left off. For us to
be able to parse an entire config file, we must have one main rule. We combine
all of the primitives that we have built so far: comments, modes, bindings,
unbinds and imports into a blanket content expression.&lt;/p&gt;</description></item><item><title>Modes, Unbinds and Other Ensembled Parser Patterns</title><link>https://lavafroth.is-a.dev/post/modes-unbinds-and-other-ensembled-parser-patterns/</link><pubDate>Mon, 10 Jun 2024 08:27:06 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/modes-unbinds-and-other-ensembled-parser-patterns/</guid><description>&lt;p&gt;Hello and welcome to the sixth instalment in this series where we build a parser
for a domain specific language from scratch. I would highly recommend you to go
through the previous articles to make sense of what we&amp;rsquo;ll talk about today.&lt;/p&gt;
&lt;p&gt;So far, we have built ranges, shorthands and bindings, starting all the way down
from primitives such as keys and modifiers. Continuing with the theme, we will
ensemble these patterns together along with some newer syntax to build modes.&lt;/p&gt;</description></item><item><title>Modeling More Realistic Keybinds With Modifiers</title><link>https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/</link><pubDate>Wed, 05 Jun 2024 10:26:13 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/</guid><description>&lt;p&gt;Real world keybindings for shortcuts often involve more than just a simple keypress, especially outside the context of
a single application. The general distinction for these two types involves modifier keys. When I talk about a shortcut
bound to &lt;code&gt;super&lt;/code&gt; &lt;code&gt;v&lt;/code&gt;, chances are you automatically think of global bindings at the operating system or desktop environment
level. Today we&amp;rsquo;ll go through the process of writing the grammar for these bindings for swhkd.&lt;/p&gt;</description></item><item><title>Edge cases? You Shall Not Pass!</title><link>https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/</link><pubDate>Mon, 03 Jun 2024 08:18:19 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/</guid><description>&lt;p&gt;This post is a part of a series that explains the architecture of the config parser
I am building for swhkd as a part of Google Summer of Code. I highly recommend reading
through the previous posts as I&amp;rsquo;ll be referring to them from time to time.&lt;/p&gt;
&lt;p&gt;In the last post I talked about key attributes that can be used as prefix to denote
the timing of an event, on key press (&lt;code&gt;send&lt;/code&gt; / &lt;code&gt;~&lt;/code&gt;) or release (&lt;code&gt;on_release&lt;/code&gt; / &lt;code&gt;@&lt;/code&gt;). One nuanced
case we did not cover was the use of these attributes inside shorthands.&lt;/p&gt;</description></item><item><title>Timing is Key: A Tale of Keystrokes and Timings</title><link>https://lavafroth.is-a.dev/post/timing-is-key/</link><pubDate>Wed, 29 May 2024 21:18:22 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/timing-is-key/</guid><description>&lt;p&gt;Whether you&amp;rsquo;re playing a video game or competing in a constrained attack-defense CTF, your keystroke timings matter.
We at waycrate value your precision, to the extent that you can configure your keybindings to perform actions either
on a key&amp;rsquo;s press or a release.&lt;/p&gt;
&lt;p&gt;Hi, my name&amp;rsquo;s Himadri and this post is a part of a series explaining how
we (basically just me) are rewriting the config parser for swhkd using EBNF
grammar. I highly recommend reading the previous posts because I&amp;rsquo;ll be referring
to them from time to time. In the last post, we talked about regular keys
that form the foundation of bindings. However, we glossed over the &lt;code&gt;send&lt;/code&gt; and
&lt;code&gt;on_release&lt;/code&gt; expressions in the code.&lt;/p&gt;</description></item><item><title>Keep the Keys Clackin'</title><link>https://lavafroth.is-a.dev/post/keep-the-keys-clackin/</link><pubDate>Mon, 27 May 2024 08:59:29 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/keep-the-keys-clackin/</guid><description>&lt;p&gt;This is the second post in a series of posts I&amp;rsquo;m writing for Google Summer of Code.
Each post covers a separate topic.
While the previous posts might have given you an overview of ideas, this post will delve
into more technical details. I highly recommend reading the previous posts because I will
refer to them from time to time.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s begin with why we chose EBNF grammar in &lt;a href="https://pest.rs"&gt;pest.rs&lt;/a&gt; instead of regular expressions.&lt;/p&gt;</description></item><item><title>2 Afternoons, 2 Languages, 2 TUIs</title><link>https://lavafroth.is-a.dev/post/2-afternoons-2-languages-2-tuis/</link><pubDate>Thu, 23 May 2024 18:37:47 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/2-afternoons-2-languages-2-tuis/</guid><description>&lt;p&gt;Yesterday I created a tool in Golang to help me render my animations a little
faster. Although the alterior reason was to check my Golang proficiency, today
I rewrote it in Rust and I was blown away by the differences in the final
products.&lt;/p&gt;
&lt;p&gt;When I&amp;rsquo;m rendering animations for a YouTube video, the general development
iteration comprises me creating or modifying a file, switching to a different
terminal pane and manually issuing a &lt;em&gt;manim&lt;/em&gt; command for the respective file to
render and play the animation. My goal was to automate the last two processes,
switching terminal panes and manually issuing a command. The idea is to have a
tool running in the background that listens for filesystem events, like when a
file gets created or modified, and if the file happens to contain an animation,
renders it. On linux systems, it&amp;rsquo;s mostly a bunch of bindings to &lt;code&gt;inotify&lt;/code&gt; but I
have used platform agnostic libraries for both the languages.&lt;/p&gt;</description></item><item><title>A SWEET Little Parser</title><link>https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/</link><pubDate>Fri, 17 May 2024 07:52:44 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/</guid><description>&lt;p&gt;A few days ago, I had announced my project for this year&amp;rsquo;s Google Summer of Code. Today I&amp;rsquo;ll
be explanding upon that. I believe that to construct a good grammar, I should be able to understand
and explain it well. So here goes.&lt;/p&gt;
&lt;h2 id="general-idea"&gt;General Idea&lt;/h2&gt;
&lt;p&gt;SWHKD&amp;rsquo;s grammar parser, although similar to tools before it like sxhkd, has a more coherent
syntax. For starters, every binding declaration is one or more accelerators followed by a composite key.&lt;/p&gt;</description></item><item><title>Wayland Tools Rock!</title><link>https://lavafroth.is-a.dev/post/wayland-tools-rock/</link><pubDate>Fri, 17 May 2024 07:52:44 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/wayland-tools-rock/</guid><description>&lt;p&gt;Hey folks. Quite a few months have passed since I last posted here.
As you might have known from my earlier posts, I&amp;rsquo;ve been daily driving
Wayland instead of Xorg on my NixOS setup for quite some time now.&lt;/p&gt;
&lt;p&gt;One of the tools I stumbled upon while writing my voice automation abomination
was SWHKD (Simple Wayland HotKey Daemon). It&amp;rsquo;s a spiritual successor to sxhkd from the Xorg world
and in a sense better than the former because it works not only in wayland sessions but also
under X and TTY sessions!&lt;/p&gt;</description></item><item><title>Abstracting Structured Patterns in Concurrent Programming</title><link>https://lavafroth.is-a.dev/post/abstracting-structured-patterns-in-concurrent-programming/</link><pubDate>Wed, 06 Dec 2023 10:58:10 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/abstracting-structured-patterns-in-concurrent-programming/</guid><description>&lt;blockquote&gt;
&lt;p&gt;I hope this article provides a solid blueprint for building a concurrency management API.
If you have questions or feel that I have missed something, feel free to talk about it in this repository&amp;rsquo;s &lt;a href="https://github.com/lavafroth/lavafroth.github.io/issues"&gt;issue tracker&lt;/a&gt; or the &lt;a href="https://github.com/lavafroth/lavafroth.github.io/discussions"&gt;discussion board&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In recent months, I have come across multiple articles talking about the need
of structured concurrency in modern programming languages as a built-in. Notably, in the article &lt;a href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/"&gt;Notes on structured concurrency, or: Go statement considered harmful&lt;/a&gt;,
the author compares the &lt;code&gt;go&lt;/code&gt; statement used to spawn coroutines to &lt;code&gt;goto&lt;/code&gt; statements used
for jumping to other parts of code in early languages like COBOL.&lt;/p&gt;</description></item><item><title>Pixelated</title><link>https://lavafroth.is-a.dev/post/picoctf-cryptography-pixelated/</link><pubDate>Tue, 22 Nov 2022 09:25:20 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/picoctf-cryptography-pixelated/</guid><description>&lt;p&gt;This challenge gives use two images and asks us if we can make a flag out of them.
At first glance, both the images look like noise. Upon a quick web lookup of
&lt;a href="https://en.wikipedia.org/wiki/Visual_cryptography"&gt;visual cryptography&lt;/a&gt;, it appears
that these separate images, known as shares of the original image, can be overlayed
on each other to reconstruct the original image.&lt;/p&gt;
&lt;h2 id="exploration"&gt;Exploration&lt;/h2&gt;
&lt;p&gt;Now, I&amp;rsquo;m pretty sure that there are online services that will automatically solve these
but I decided to write some code to solve this locally. For the past week, I&amp;rsquo;ve been
learning the Rust programming language and this was the perfect excuse to test my knowledge.&lt;/p&gt;</description></item></channel></rss>