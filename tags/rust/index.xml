<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on lavafroth</title><link>https://lavafroth.is-a.dev/tags/rust/</link><description>Recent content in Rust on lavafroth</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Mon, 29 Jul 2024 13:46:41 +0530</lastBuildDate><atom:link href="https://lavafroth.is-a.dev/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Polishing and Bugfix Week</title><link>https://lavafroth.is-a.dev/post/polishing-and-bugfix-week/</link><pubDate>Mon, 29 Jul 2024 13:46:41 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/polishing-and-bugfix-week/</guid><description>Hello and welcome to the last instalment in the series where we build a parser for a domain specific langauge in Rust. Please go through the previous articles since this article assumes you are aware of such contextual details.
Let&amp;rsquo;s start with the bugfixes.
Eagerly removing unbinds While going through the tests, I figured that the prior parser eagerly parses unbinds and removes said keystroke combinations from our binding set. Unlike the previous iteration, our iteration had unbinds as a separate set which deferred the task of the removing the set intersection to the upstream crate instead.</description></item><item><title>Humans Suck at Command Sanitization</title><link>https://lavafroth.is-a.dev/post/humans-suck-at-command-sanitization/</link><pubDate>Wed, 17 Jul 2024 07:55:34 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/humans-suck-at-command-sanitization/</guid><description>Hello and welcome to the eighth instalment in the series where we build a parser for a domain specific language in Rust. I’d highly recommend going through the previous articles to make sense of what we’ll talk about today.
Previously, we had built the scaffolding for modes to bind shortcuts to. Today, we&amp;rsquo;ll create the mechanism to invoke commands in the contexts of the modes that can be built.
Now, SWHKD has a clever way to enter (and escape) mode contexts with inside commands by chaining subcommands and mode instructions with double ampersands.</description></item><item><title>Preventing Infinite Recursions From Eating Your Lunch</title><link>https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/</link><pubDate>Thu, 04 Jul 2024 09:57:01 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/</guid><description>Hello and welcome to the eighth instalment in the series where we build a parser for a domain specific language in Rust. I&amp;rsquo;d highly recommend going through the previous articles to make sense of what we’ll talk about today.
After a bit of back and forth with my mentor, we landed on moving the logic that imports other config files into the parser crate itself. Config files can reference other modules using import statements of the following form:</description></item><item><title>Test Driven Development - The Pinnacle of Engineering</title><link>https://lavafroth.is-a.dev/post/test-driven-development-the-pinnacle-of-engineering/</link><pubDate>Mon, 24 Jun 2024 08:45:49 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/test-driven-development-the-pinnacle-of-engineering/</guid><description>Hello and welcome to the seventh instalment in the series where we build a parser for a domain specific language in Rust. I would highly recommend you to go through the previous articles to make sense of what we’ll talk about today.
Tying loose ends Up until the last post, we had covered quite some ground, from building elementary expressions to the penultimate levels of abstraction for macroscopic expressions.
Let&amp;rsquo;s begin today&amp;rsquo;s conversation by finishing off where we left off.</description></item><item><title>Modes, Unbinds and Other Ensembled Parser Patterns</title><link>https://lavafroth.is-a.dev/post/modes-unbinds-and-other-ensembled-parser-patterns/</link><pubDate>Mon, 10 Jun 2024 08:27:06 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/modes-unbinds-and-other-ensembled-parser-patterns/</guid><description>Hello and welcome to the sixth instalment in this series where we build a parser for a domain specific language from scratch. I would highly recommend you to go through the previous articles to make sense of what we&amp;rsquo;ll talk about today.
So far, we have built ranges, shorthands and bindings, starting all the way down from primitives such as keys and modifiers. Continuing with the theme, we will ensemble these patterns together along with some newer syntax to build modes.</description></item><item><title>Modeling More Realistic Keybinds With Modifiers</title><link>https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/</link><pubDate>Wed, 05 Jun 2024 10:26:13 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/</guid><description>Real world keybindings for shortcuts often involve more than just a simple keypress, especially outside the context of a single application. The general distinction for these two types involves modifier keys. When I talk about a shortcut bound to super v, chances are you automatically think of global bindings at the operating system or desktop environment level. Today we&amp;rsquo;ll go through the process of writing the grammar for these bindings for swhkd.</description></item><item><title>Edge cases? You Shall Not Pass!</title><link>https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/</link><pubDate>Mon, 03 Jun 2024 08:18:19 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/</guid><description>This post is a part of a series that explains the architecture of the config parser I am building for swhkd as a part of Google Summer of Code. I highly recommend reading through the previous posts as I&amp;rsquo;ll be referring to them from time to time.
In the last post I talked about key attributes that can be used as prefix to denote the timing of an event, on key press (send / ~) or release (on_release / @).</description></item><item><title>Timing is Key: A Tale of Keystrokes and Timings</title><link>https://lavafroth.is-a.dev/post/timing-is-key/</link><pubDate>Wed, 29 May 2024 21:18:22 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/timing-is-key/</guid><description>Whether you&amp;rsquo;re playing a video game or competing in a constrained attack-defense CTF, your keystroke timings matter. We at waycrate value your precision, to the extent that you can configure your keybindings to perform actions either on a key&amp;rsquo;s press or a release.
Hi, my name&amp;rsquo;s Himadri and this post is a part of a series explaining how we (basically just me) are rewriting the config parser for swhkd using EBNF grammar.</description></item><item><title>Keep the Keys Clackin'</title><link>https://lavafroth.is-a.dev/post/keep-the-keys-clackin/</link><pubDate>Mon, 27 May 2024 08:59:29 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/keep-the-keys-clackin/</guid><description>This is the second post in a series of posts I&amp;rsquo;m writing for Google Summer of Code. Each post covers a separate topic. While the previous posts might have given you an overview of ideas, this post will delve into more technical details. I highly recommend reading the previous posts because I will refer to them from time to time.
Let&amp;rsquo;s begin with why we chose EBNF grammar in pest.rs instead of regular expressions.</description></item><item><title>2 Afternoons, 2 Languages, 2 TUIs</title><link>https://lavafroth.is-a.dev/post/2-afternoons-2-languages-2-tuis/</link><pubDate>Thu, 23 May 2024 18:37:47 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/2-afternoons-2-languages-2-tuis/</guid><description>Yesterday I created a tool in Golang to help me render my animations a little faster. Although the alterior reason was to check my Golang proficiency, today I rewrote it in Rust and I was blown away by the differences in the final products.
When I&amp;rsquo;m rendering animations for a YouTube video, the general development iteration comprises me creating or modifying a file, switching to a different terminal pane and manually issuing a manim command for the respective file to render and play the animation.</description></item><item><title>A SWEET Little Parser</title><link>https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/</link><pubDate>Fri, 17 May 2024 07:52:44 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/</guid><description>A few days ago, I had announced my project for this year&amp;rsquo;s Google Summer of Code. Today I&amp;rsquo;ll be explanding upon that. I believe that to construct a good grammar, I should be able to understand and explain it well. So here goes.
General Idea SWHKD&amp;rsquo;s grammar parser, although similar to tools before it like sxhkd, has a more coherent syntax. For starters, every binding declaration is one or more accelerators followed by a composite key.</description></item><item><title>Wayland Tools Rock!</title><link>https://lavafroth.is-a.dev/post/wayland-tools-rock/</link><pubDate>Fri, 17 May 2024 07:52:44 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/wayland-tools-rock/</guid><description>Hey folks. Quite a few months have passed since I last posted here. As you might have known from my earlier posts, I&amp;rsquo;ve been daily driving Wayland instead of Xorg on my NixOS setup for quite some time now.
One of the tools I stumbled upon while writing my voice automation abomination was SWHKD (Simple Wayland HotKey Daemon). It&amp;rsquo;s a spiritual successor to sxhkd from the Xorg world and in a sense better than the former because it works not only in wayland sessions but also under X and TTY sessions!</description></item><item><title>Abstracting Structured Patterns in Concurrent Programming</title><link>https://lavafroth.is-a.dev/post/abstracting-structured-patterns-in-concurrent-programming/</link><pubDate>Wed, 06 Dec 2023 10:58:10 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/abstracting-structured-patterns-in-concurrent-programming/</guid><description>I hope this article provides a solid blueprint for building a concurrency management API. If you have questions or feel that I have missed something, feel free to talk about it in this repository&amp;rsquo;s issue tracker or the discussion board.
In recent months, I have come across multiple articles talking about the need of structured concurrency in modern programming languages as a built-in. Notably, in the article Notes on structured concurrency, or: Go statement considered harmful, the author compares the go statement used to spawn coroutines to goto statements used for jumping to other parts of code in early languages like COBOL.</description></item><item><title>Pixelated</title><link>https://lavafroth.is-a.dev/post/picoctf-cryptography-pixelated/</link><pubDate>Tue, 22 Nov 2022 09:25:20 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/picoctf-cryptography-pixelated/</guid><description>This challenge gives use two images and asks us if we can make a flag out of them. At first glance, both the images look like noise. Upon a quick web lookup of visual cryptography, it appears that these separate images, known as shares of the original image, can be overlayed on each other to reconstruct the original image.
Exploration Now, I&amp;rsquo;m pretty sure that there are online services that will automatically solve these but I decided to write some code to solve this locally.</description></item></channel></rss>