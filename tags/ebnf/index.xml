<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>EBNF on lavafroth</title><link>https://lavafroth.is-a.dev/tags/ebnf/</link><description>Recent content in EBNF on lavafroth</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Thu, 04 Jul 2024 09:57:01 +0530</lastBuildDate><atom:link href="https://lavafroth.is-a.dev/tags/ebnf/index.xml" rel="self" type="application/rss+xml"/><item><title>Preventing Infinite Recursions From Eating Your Lunch</title><link>https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/</link><pubDate>Thu, 04 Jul 2024 09:57:01 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/</guid><description>Hello and welcome to the eighth instalment in the series where we build a parser for a domain specific language in Rust. I&amp;rsquo;d highly recommend going through the previous articles to make sense of what we’ll talk about today.
After a bit of back and forth with my mentor, we landed on moving the logic that imports other config files into the parser crate itself. Config files can reference other modules using import statements of the following form:</description></item><item><title>Test Driven Development - the Pinnacle of Engineering</title><link>https://lavafroth.is-a.dev/post/test-driven-development-the-pinnacle-of-engineering/</link><pubDate>Mon, 24 Jun 2024 08:45:49 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/test-driven-development-the-pinnacle-of-engineering/</guid><description>Hello and welcome to the seventh instalment in the series where we build a parser for a domain specific language in Rust. I would highly recommend you to go through the previous articles to make sense of what we’ll talk about today.
Tying loose ends Up until the last post, we had covered quite some ground, from building elementary expressions to the penultimate levels of abstraction for macroscopic expressions.
Let&amp;rsquo;s begin today&amp;rsquo;s conversation by finishing off where we left off.</description></item><item><title>Modes, Unbinds and Other Ensembled Parser Patterns</title><link>https://lavafroth.is-a.dev/post/modes-unbinds-and-other-ensembled-parser-patterns/</link><pubDate>Mon, 10 Jun 2024 08:27:06 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/modes-unbinds-and-other-ensembled-parser-patterns/</guid><description>Hello and welcome to the sixth instalment in this series where we build a parser for a domain specific language from scratch. I would highly recommend you to go through the previous articles to make sense of what we&amp;rsquo;ll talk about today.
So far, we have built ranges, shorthands and bindings, starting all the way down from primitives such as keys and modifiers. Continuing with the theme, we will ensemble these patterns together along with some newer syntax to build modes.</description></item><item><title>Modeling More Realistic Keybinds With Modifiers</title><link>https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/</link><pubDate>Wed, 05 Jun 2024 10:26:13 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/</guid><description>Real world keybindings for shortcuts often involve more than just a simple keypress, especially outside the context of a single application. The general distinction for these two types involves modifier keys. When I talk about a shortcut bound to super v, chances are you automatically think of global bindings at the operating system or desktop environment level. Today we&amp;rsquo;ll go through the process of writing the grammar for these bindings for swhkd.</description></item><item><title>Edge cases? You Shall Not Pass!</title><link>https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/</link><pubDate>Mon, 03 Jun 2024 08:18:19 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/</guid><description>This post is a part of a series that explains the architecture of the config parser I am building for swhkd as a part of Google Summer of Code. I highly recommend reading through the previous posts as I&amp;rsquo;ll be referring to them from time to time.
In the last post I talked about key attributes that can be used as prefix to denote the timing of an event, on key press (send / ~) or release (on_release / @).</description></item><item><title>Timing is Key: A Tale of Keystrokes and Timings</title><link>https://lavafroth.is-a.dev/post/timing-is-key/</link><pubDate>Wed, 29 May 2024 21:18:22 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/timing-is-key/</guid><description>Whether you&amp;rsquo;re playing a video game or competing in a constrained attack-defense CTF, your keystroke timings matter. We at waycrate value your precision, to the extent that you can configure your keybindings to perform actions either on a key&amp;rsquo;s press or a release.
Hi, my name&amp;rsquo;s Himadri and this post is a part of a series explaining how we (basically just me) are rewriting the config parser for swhkd using EBNF grammar.</description></item><item><title>Keep the Keys Clackin'</title><link>https://lavafroth.is-a.dev/post/keep-the-keys-clackin/</link><pubDate>Mon, 27 May 2024 08:59:29 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/keep-the-keys-clackin/</guid><description>This is the second post in a series of posts I&amp;rsquo;m writing for Google Summer of Code. Each post covers a separate topic. While the previous posts might have given you an overview of ideas, this post will delve into more technical details. I highly recommend reading the previous posts because I will refer to them from time to time.
Let&amp;rsquo;s begin with why we chose EBNF grammar in pest.rs instead of regular expressions.</description></item><item><title>A SWEET Little Parser</title><link>https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/</link><pubDate>Fri, 17 May 2024 07:52:44 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/</guid><description>A few days ago, I had announced my project for this year&amp;rsquo;s Google Summer of Code. Today I&amp;rsquo;ll be explanding upon that. I believe that to construct a good grammar, I should be able to understand and explain it well. So here goes.
General Idea SWHKD&amp;rsquo;s grammar parser, although similar to tools before it like sxhkd, has a more coherent syntax. For starters, every binding declaration is one or more accelerators followed by a composite key.</description></item><item><title>Wayland Tools Rock!</title><link>https://lavafroth.is-a.dev/post/wayland-tools-rock/</link><pubDate>Fri, 17 May 2024 07:52:44 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/wayland-tools-rock/</guid><description>Hey folks. Quite a few months have passed since I last posted here. As you might have known from my earlier posts, I&amp;rsquo;ve been daily driving Wayland instead of Xorg on my NixOS setup for quite some time now.
One of the tools I stumbled upon while writing my voice automation abomination was SWHKD (Simple Wayland HotKey Daemon). It&amp;rsquo;s a spiritual successor to sxhkd from the Xorg world and in a sense better than the former because it works not only in wayland sessions but also under X and TTY sessions!</description></item></channel></rss>