<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Wayland on lavafroth</title><link>https://lavafroth.is-a.dev/tags/wayland/</link><description>Recent content in Wayland on lavafroth</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 24 Aug 2024 10:28:50 +0530</lastBuildDate><atom:link href="https://lavafroth.is-a.dev/tags/wayland/index.xml" rel="self" type="application/rss+xml"/><item><title>Wrapping up GSoC 2024</title><link>https://lavafroth.is-a.dev/post/the-gsoc-grand-finale/</link><pubDate>Sat, 24 Aug 2024 10:28:50 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/the-gsoc-grand-finale/</guid><description>&lt;h1 id="overview">Overview&lt;/h1>
&lt;p>Hello and welcome to the final GSoC post for 2024! My task was to formalize the SWHKD parser using context-free EBNF notation. This post is to serve as a birdseye view of what
I have developed over this summer.&lt;/p>
&lt;h1 id="report">Report&lt;/h1>
&lt;h2 id="architecting-the-parser">Architecting the parser&lt;/h2>
&lt;p>I started out with the scaffolding of the parser in an extended Backus-Naur form garmmar template
in a separate repository called &lt;a href="https://github.com/waycrate/sweet">SWEET&lt;/a> using a Rust framework
called &lt;a href="https://pest.rs">pest.rs&lt;/a>. Quite a lot of time was
spent in modelling the architecture of the syntax tree for our domain specific language.&lt;/p></description></item><item><title>How I Use SWHKD in My Workflow</title><link>https://lavafroth.is-a.dev/post/how-i-use-swhkd-in-my-workflow/</link><pubDate>Thu, 01 Aug 2024 17:17:31 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/how-i-use-swhkd-in-my-workflow/</guid><description>&lt;p>SWHKD is the project that I have been working on for the past few months as a part of Google Summer of Code for this year.
Now that we are done with the development process, I want to talk about why I wanted to improve the project. Although
the easy answer is to get paid or to get a more production facing OSS development experience,
for me, the most important driving force is using it in my own workflow.&lt;/p></description></item><item><title>Polishing and Bugfix Week</title><link>https://lavafroth.is-a.dev/post/polishing-and-bugfix-week/</link><pubDate>Mon, 29 Jul 2024 13:46:41 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/polishing-and-bugfix-week/</guid><description>&lt;p>Hello and welcome to the last instalment in the series where we build a parser
for a domain specific langauge in Rust. Please go through the previous articles
since this article assumes you are aware of such contextual details.&lt;/p>
&lt;p>Let&amp;rsquo;s start with the bugfixes.&lt;/p>
&lt;h1 id="eagerly-removing-unbinds">Eagerly removing unbinds&lt;/h1>
&lt;p>While going through the tests, I figured that
the prior parser eagerly parses unbinds and removes said keystroke combinations
from our binding set. Unlike the previous iteration, our iteration had unbinds
as a separate set which deferred the task of the removing the set intersection
to the upstream crate instead.&lt;/p></description></item><item><title>Humans Suck at Command Sanitization</title><link>https://lavafroth.is-a.dev/post/humans-suck-at-command-sanitization/</link><pubDate>Wed, 17 Jul 2024 07:55:34 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/humans-suck-at-command-sanitization/</guid><description>&lt;p>Hello and welcome to the eighth instalment in the series where we build a parser
for a domain specific language in Rust. I’d highly recommend going through the
previous articles to make sense of what we’ll talk about today.&lt;/p>
&lt;p>Previously, we had built the scaffolding for modes to bind shortcuts to. Today,
we&amp;rsquo;ll create the mechanism to invoke commands in the contexts of the modes that
can be built.&lt;/p>
&lt;p>Now, SWHKD has a clever way to enter (and escape) mode contexts with inside commands
by chaining subcommands and mode instructions with double ampersands. Consider the following example:&lt;/p></description></item><item><title>Preventing Infinite Recursions From Eating Your Lunch</title><link>https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/</link><pubDate>Thu, 04 Jul 2024 09:57:01 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/</guid><description>&lt;p>Hello and welcome to the eighth instalment in the series where we build a
parser for a domain specific language in Rust. I&amp;rsquo;d highly recommend
going through the previous articles to make sense of what we’ll talk about today.&lt;/p>
&lt;p>After a bit of back and forth with my mentor, we landed on moving the logic that imports
other config files into the parser crate itself. Config files can reference other modules
using import statements of the following form:&lt;/p></description></item><item><title>Test Driven Development - The Pinnacle of Engineering</title><link>https://lavafroth.is-a.dev/post/test-driven-development-the-pinnacle-of-engineering/</link><pubDate>Mon, 24 Jun 2024 08:45:49 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/test-driven-development-the-pinnacle-of-engineering/</guid><description>&lt;p>Hello and welcome to the seventh instalment in the series where we build a
parser for a domain specific language in Rust. I would highly recommend you to
go through the previous articles to make sense of what we’ll talk about today.&lt;/p>
&lt;h2 id="tying-loose-ends">Tying loose ends&lt;/h2>
&lt;p>Up until the last post, we had covered quite some ground, from building
elementary expressions to the penultimate levels of abstraction for macroscopic
expressions.&lt;/p>
&lt;p>Let&amp;rsquo;s begin today&amp;rsquo;s conversation by finishing off where we left off. For us to
be able to parse an entire config file, we must have one main rule. We combine
all of the primitives that we have built so far: comments, modes, bindings,
unbinds and imports into a blanket content expression.&lt;/p></description></item><item><title>Modes, Unbinds and Other Ensembled Parser Patterns</title><link>https://lavafroth.is-a.dev/post/modes-unbinds-and-other-ensembled-parser-patterns/</link><pubDate>Mon, 10 Jun 2024 08:27:06 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/modes-unbinds-and-other-ensembled-parser-patterns/</guid><description>&lt;p>Hello and welcome to the sixth instalment in this series where we build a parser
for a domain specific language from scratch. I would highly recommend you to go
through the previous articles to make sense of what we&amp;rsquo;ll talk about today.&lt;/p>
&lt;p>So far, we have built ranges, shorthands and bindings, starting all the way down
from primitives such as keys and modifiers. Continuing with the theme, we will
ensemble these patterns together along with some newer syntax to build modes.&lt;/p></description></item><item><title>Modeling More Realistic Keybinds With Modifiers</title><link>https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/</link><pubDate>Wed, 05 Jun 2024 10:26:13 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/</guid><description>&lt;p>Real world keybindings for shortcuts often involve more than just a simple keypress, especially outside the context of
a single application. The general distinction for these two types involves modifier keys. When I talk about a shortcut
bound to &lt;code>super&lt;/code> &lt;code>v&lt;/code>, chances are you automatically think of global bindings at the operating system or desktop environment
level. Today we&amp;rsquo;ll go through the process of writing the grammar for these bindings for swhkd.&lt;/p></description></item><item><title>Edge cases? You Shall Not Pass!</title><link>https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/</link><pubDate>Mon, 03 Jun 2024 08:18:19 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/</guid><description>&lt;p>This post is a part of a series that explains the architecture of the config parser
I am building for swhkd as a part of Google Summer of Code. I highly recommend reading
through the previous posts as I&amp;rsquo;ll be referring to them from time to time.&lt;/p>
&lt;p>In the last post I talked about key attributes that can be used as prefix to denote
the timing of an event, on key press (&lt;code>send&lt;/code> / &lt;code>~&lt;/code>) or release (&lt;code>on_release&lt;/code> / &lt;code>@&lt;/code>). One nuanced
case we did not cover was the use of these attributes inside shorthands.&lt;/p></description></item><item><title>Timing is Key: A Tale of Keystrokes and Timings</title><link>https://lavafroth.is-a.dev/post/timing-is-key/</link><pubDate>Wed, 29 May 2024 21:18:22 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/timing-is-key/</guid><description>&lt;p>Whether you&amp;rsquo;re playing a video game or competing in a constrained attack-defense CTF, your keystroke timings matter.
We at waycrate value your precision, to the extent that you can configure your keybindings to perform actions either
on a key&amp;rsquo;s press or a release.&lt;/p>
&lt;p>Hi, my name&amp;rsquo;s Himadri and this post is a part of a series explaining how
we (basically just me) are rewriting the config parser for swhkd using EBNF
grammar. I highly recommend reading the previous posts because I&amp;rsquo;ll be referring
to them from time to time. In the last post, we talked about regular keys
that form the foundation of bindings. However, we glossed over the &lt;code>send&lt;/code> and
&lt;code>on_release&lt;/code> expressions in the code.&lt;/p></description></item><item><title>Keep the Keys Clackin'</title><link>https://lavafroth.is-a.dev/post/keep-the-keys-clackin/</link><pubDate>Mon, 27 May 2024 08:59:29 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/keep-the-keys-clackin/</guid><description>&lt;p>This is the second post in a series of posts I&amp;rsquo;m writing for Google Summer of Code.
Each post covers a separate topic.
While the previous posts might have given you an overview of ideas, this post will delve
into more technical details. I highly recommend reading the previous posts because I will
refer to them from time to time.&lt;/p>
&lt;p>Let&amp;rsquo;s begin with why we chose EBNF grammar in &lt;a href="https://pest.rs">pest.rs&lt;/a> instead of regular expressions.&lt;/p></description></item><item><title>A SWEET Little Parser</title><link>https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/</link><pubDate>Fri, 17 May 2024 07:52:44 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/</guid><description>&lt;p>A few days ago, I had announced my project for this year&amp;rsquo;s Google Summer of Code. Today I&amp;rsquo;ll
be explanding upon that. I believe that to construct a good grammar, I should be able to understand
and explain it well. So here goes.&lt;/p>
&lt;h2 id="general-idea">General Idea&lt;/h2>
&lt;p>SWHKD&amp;rsquo;s grammar parser, although similar to tools before it like sxhkd, has a more coherent
syntax. For starters, every binding declaration is one or more accelerators followed by a composite key.&lt;/p></description></item><item><title>Wayland Tools Rock!</title><link>https://lavafroth.is-a.dev/post/wayland-tools-rock/</link><pubDate>Fri, 17 May 2024 07:52:44 +0530</pubDate><guid>https://lavafroth.is-a.dev/post/wayland-tools-rock/</guid><description>&lt;p>Hey folks. Quite a few months have passed since I last posted here.
As you might have known from my earlier posts, I&amp;rsquo;ve been daily driving
Wayland instead of Xorg on my NixOS setup for quite some time now.&lt;/p>
&lt;p>One of the tools I stumbled upon while writing my voice automation abomination
was SWHKD (Simple Wayland HotKey Daemon). It&amp;rsquo;s a spiritual successor to sxhkd from the Xorg world
and in a sense better than the former because it works not only in wayland sessions but also
under X and TTY sessions!&lt;/p></description></item></channel></rss>