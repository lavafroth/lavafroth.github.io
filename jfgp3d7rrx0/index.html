<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>secret note jfgp3d7rrx0 - lavafroth</title><meta name=description content='There will be an explanation for non-trivial questions.
Activity 1
1
Dijkstra&rsquo;s algorithm guarantees finding the shortest path from a single source to all other vertices under which of the following conditions?
Answer: All edge weights must be non-negative.
2
Consider an undirected graph with 5 vertices (V0,V1,V2,V3,V4)(V_0, V_1, V_2, V_3, V_4). At a certain point
in Dijkstra&rsquo;s algorithm (starting from V0V_0), the current tentative distances are:
dist={V0:0,V1:5,V2:3,V3:8,V4:10}dist = \{V_0:0, V_1:5, V_2:3, V_3:8, V_4:10\}. And the processed set is: {V0:True,V1:False,V2:False,V3:False,V4:False}\{V_0:True, 
V_1:False, V_2:False, V_3:False, V_4:False\}. Assuming the next step is to select an unvisited
vertex to mark as processed, which vertex will be chosen?'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/rss.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body><header><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2080"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a><nav><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../art/ aria-label=art style=--url:url(./art.svg)></a><a href=../index.xml aria-label=rss style=--url:url(./rss.svg)></a><nav></header><main><hgroup data-pagefind-body><p data-pagefind-ignore><time>Oct 28, 2025 | 13 minutes read</time></p><h1 data-pagefind-meta=title>secret note jfgp3d7rrx0</h1></hgroup><section class=post-content data-pagefind-body><p>There will be an explanation for non-trivial questions.</p><h1 id=activity-1>Activity 1</h1><h2 id=1>1</h2><p>Dijkstra&rsquo;s algorithm guarantees finding the shortest path from a single source to all other vertices under which of the following conditions?</p><p><strong>Answer:</strong> All edge weights must be non-negative.</p><h2 id=2>2</h2><p>Consider an undirected graph with 5 vertices <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V_0, V_1, V_2, V_3, V_4)</annotation></semantics></math></span>. At a certain point
in Dijkstra&rsquo;s algorithm (starting from <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">V_0</annotation></semantics></math></span>), the current tentative distances are:
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>V</mi><mn>0</mn></msub><mo>:</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>V</mi><mn>1</mn></msub><mo>:</mo><mn>5</mn><mo separator="true">,</mo><msub><mi>V</mi><mn>2</mn></msub><mo>:</mo><mn>3</mn><mo separator="true">,</mo><msub><mi>V</mi><mn>3</mn></msub><mo>:</mo><mn>8</mn><mo separator="true">,</mo><msub><mi>V</mi><mn>4</mn></msub><mo>:</mo><mn>10</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">dist = \{V_0:0, V_1:5, V_2:3, V_3:8, V_4:10\}</annotation></semantics></math></span>. And the processed set is: <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>V</mi><mn>0</mn></msub><mo>:</mo><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>V</mi><mn>1</mn></msub><mo>:</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>V</mi><mn>2</mn></msub><mo>:</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>V</mi><mn>3</mn></msub><mo>:</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>V</mi><mn>4</mn></msub><mo>:</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{V_0:True, 
V_1:False, V_2:False, V_3:False, V_4:False\}</annotation></semantics></math></span>. Assuming the next step is to select an unvisited
vertex to mark as processed, which vertex will be chosen?</p><p><strong>Answer:</strong> <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_2</annotation></semantics></math></span></p><p>Explanation: Dijkstra will choose the next unprocessed vertex with the least weight.</p><h2 id=3>3</h2><p>Which of the following components is/are essential for a standard implementation of Dijkstra&rsquo;s algorithm?</p><p><strong>Answers:</strong></p><ul><li>A way to store the tentative shortest distance to each vertex.</li><li>A set to keep track of vertices whose shortest paths have been finalized.</li><li>A mechanism to select the unvisited vertex with the smallest current distance.</li></ul><h2 id=4>4</h2><p>Consider an undirected graph with vertices S, A, B, C, D and edges with weights: S-A (4), S-B (2), A-C (5), B-A (1), B-D (8), C-D (3). If Dijkstra&rsquo;s algorithm starts from vertex &lsquo;S&rsquo;, what is the value of dist[D] immediately after vertex &lsquo;A&rsquo; has been marked as processed?</p><p><strong>Answer:</strong> 10</p><h2 id=5>5</h2><p>When Dijkstra&rsquo;s algorithm is examining an edge (u, v) from a newly processed vertex u , and it finds that the path source -> &mldr; -> u -> v offers a shorter route to v than its currently recorded shortest distance ( dist[v] ), what is the direct consequence for dist[v] and v &rsquo;s status?</p><p><strong>Answer:</strong>
dist[v] is updated, and v&rsquo;s status remains un-processed, awaiting its turn in a future selection step</p><h2 id=6>6</h2><p>Given a weighted graph where weights of all edges are unique, there is always a unique shortest path from a source to destination in such a graph.</p><p><strong>Answer:</strong> False</p><p>Explanation: There can be multiple sequence of edges from vertex <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span> to <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span> representing the shortest path. The only necessary property is that the sum of the weights on these edges is the least.</p><h1 id=activity-2>Activity 2</h1><h2 id=1-1>1</h2><p>What is a fundamental capability of the Bellman-Ford algorithm that distinguishes it from Dijkstra&rsquo;s algorithm for finding shortest paths?</p><p><strong>Answer:</strong> It is able to correctly find shortest paths in graphs containing negative edge weights.</p><h2 id=2-1>2</h2><p>For a graph with 7 vertices and 10 edges, if it contains no negative cycles, what is the minimum number of passes over all edges that the Bellman-Ford algorithm needs to perform to guarantee that all shortest path distances are finalized?</p><p><strong>Answer:</strong> 6</p><h2 id=3-1>3</h2><p>Consider the following directed graph. If the Bellman-Ford algorithm starts from vertex &lsquo;S&rsquo;, what are the shortest distances to vertices &lsquo;A&rsquo;, &lsquo;B&rsquo;, and &lsquo;C&rsquo; (in that order: dist[A] , dist[B] , dist[C] ) after exactly 2 passes over all edges?</p><p><strong>Answer:</strong> 6</p><p>Explanation: It takes <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>âˆ’</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span> iterations for a graph with <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span> edges to stabilize via Bellman Ford if there are no negative edges.</p><p>If the graph stabilizes further from the <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span> iteration onwards, it contains negative cycles.</p><h2 id=4-1>4</h2><p>When Bellman-Ford performs a pass over all edges, does the order in which edges are relaxed within that single pass affect the final shortest path distances after all Vâˆ’1 passes (assuming no negative cycles are present)?</p><p><strong>Answer:</strong> No, the order of edge relaxation within a pass does not affect the final distances after all Vâˆ’1 passes.</p><h2 id=5-1>5</h2><p>Which of the following statements accurately describe properties or uses of the Bellman-Ford algorithm?</p><p><strong>Answers:</strong></p><ul><li>If a negative cycle is detected, the algorithm reports its presence and may not produce valid shortest paths for affected vertices.</li><li>The algorithm is suitable for distributed shortest path computation.</li></ul><h2 id=6-1>6</h2><p>Given a graph where all edges have positive weights, the shortest path produced by Dijkstra&rsquo;s and Bellman Ford algorithm may be different but path weight would be same.</p><p><strong>Answer:</strong> True</p><h1 id=activity-3>Activity 3</h1><h2 id=1-2>1</h2><p>What type of shortest path problem is the Floyd-Warshall algorithm designed to solve?</p><p><strong>Answer:</strong> All-pairs shortest paths in graphs with negative edge weights or positive edge weights (but no negative cycles).</p><h2 id=2-2>2</h2><p>The core update rule in Floyd-Warshall is</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</annotation></semantics></math></span><p>What does the variable k fundamentally represent in this context?</p><p><strong>Answer:</strong> An intermediate vertex that might lie on a shortest path from i to j</p><h2 id=3-2>3</h2><p>What is the time complexity of the Floyd-Warshall algorithm for a graph with N vertices?</p><p><strong>Answer:</strong> <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span></p><h2 id=4-2>4</h2><p>How does the Floyd-Warshall algorithm detect the presence of a negative weight cycle in the graph?</p><p><strong>Answer:</strong> By observing if any dist[i][i] (distance from a vertex to itself) becomes negative after all iterations</p><h2 id=5-2>5</h2><p>Consider a graph with 3 vertices {1, 2, 3}. The initial distance matrix dist is given as: dist[1][1] = 0, dist[1][2] = 2, dist[1][3] = 7 dist[2][1] = inf, dist[2][2] = 0, dist[2][3] = 3 dist[3][1] = inf, dist[3][2] = inf, dist[3][3] = 0</p><p>What is the value of dist[1][3] after the iteration where k = 2 is considered as the intermediate vertex?</p><p><strong>Answer:</strong> 5</p><h2 id=6-2>6</h2><p>Consider a graph with 3 vertices {1, 2, 3}. The initial distance matrix dist is set up. dist[1][1]=0, dist[1] [2]=5, dist[1][3]=inf dist[2][1]=inf, dist[2][2]=0, dist[2][3]=2 dist[3][1]=inf, dist[3] [2]=inf, dist[3][3]=0</p><p>After all iterations of the Floyd-Warshall algorithm, what will be the value of <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dist[3][1]</annotation></semantics></math></span>?</p><p><strong>Answer:</strong> inf</p><p>Explanation: The distance of 3 to 1 is never updated.</p><h1 id=activity-4>Activity 4</h1><h2 id=1-3>1</h2><p>Prim&rsquo;s algorithm builds the Minimum Spanning Tree (MST) by iteratively adding edges. At each step, which type of edge does it always select?</p><p><strong>Answer:</strong> The edge with the smallest weight that connects a vertex already in the MST to a vertex not yet in the MST</p><h2 id=2-3>2</h2><p>Consider the following undirected graph. If Prim&rsquo;s algorithm starts from vertex &lsquo;A&rsquo;, what is the total weight of the Minimum Spanning Tree (MST) it finds?</p><p>Graph: A-B (4), A-C (2), B-C (5), B-D (10), C-D (3), C-E (7), D-E (1)</p><p><strong>Answer:</strong> 10</p><h2 id=3-3>3</h2><p>A connected, undirected graph has 6 vertices and 7 edges. If Prim&rsquo;s algorithm is used to find its Minimum Spanning Tree, how many edges will be included in the final MST?</p><p><strong>Answer:</strong> 5</p><h2 id=4-3>4</h2><p>When is the Minimum Spanning Tree (MST) of a connected, weighted graph guaranteed to be unique?</p><p><strong>Answer:</strong> If all edge weights in the graph are distinct.</p><h2 id=5-3>5</h2><p>Suppose Prim&rsquo;s algorithm has constructed an MST for a graph. If the weight of an edge not currently in the MST is decreased, will the existing MST always change?</p><p><strong>Answer:</strong> Not necessarily; the MST will change only if the decreased edge becomes the new minimum edge across some cut that was previously crossed by a different (heavier) MST edge.</p><h2 id=6-3>6</h2><p>If Prim&rsquo;s algorithm has generated a Minimum Spanning Tree (MST) for a connected graph, the unique path between any two vertices within that MST is always the shortest path between those two vertices in the original graph</p><p><strong>Answer:</strong> False</p><h1 id=activity-5>Activity 5</h1><h2 id=1-4>1</h2><p>Which of the following statements about how Kruskal&rsquo;s algorithm constructs the MST are true?</p><p><strong>Answer:</strong> (Yes there is only one I think is correct)</p><ul><li>It adds an edge only if it connects two vertices that belong to different existing components.</li></ul><h2 id=2-4>2</h2><p>A graph has 5 vertices {V1, V2, V3, V4, V5}. Kruskal&rsquo;s algorithm is applied. Initially, each vertex is in its own set: {V1}, {V2}, {V3}, {V4}, {V5}. Consider the following sequence of edges processed by Kruskal&rsquo;s algorithm:</p><p>(V1, V2) - weight 2
(V3, V4) - weight 3
(V1, V3) - weight 4
(V2, V4) - weight 5
(V5, V2) - weight 6</p><p>How many distinct connected components are there after these 5 edges have been processed and decisions made?</p><p><strong>Answer:</strong> 1</p><h2 id=3-4>3</h2><p>If Kruskal&rsquo;s algorithm considers an edge e and decides not to include it in the MST, what is the precise reason for this exclusion?</p><p><strong>Answer:</strong> Adding edge e would connect two vertices that are already in the same connected component within the set of edges already chosen for the MST.</p><h2 id=4-4>4</h2><p>A graph has 7 vertices and consists of 3 distinct connected components. Kruskal&rsquo;s algorithm is executed on this graph. Assuming all components are non-empty and connected internally, how many edges will Kruskal&rsquo;s algorithm include in the resulting Minimum Spanning Forest (MSF)?</p><p><strong>Answer:</strong> 4</p><h2 id=5-4>5</h2><p>If Kruskal&rsquo;s algorithm rejects an edge e (meaning e is not included in the MST), it implies that e is the heaviest edge in any cycle that e forms with edges already selected for the MST.</p><p><strong>Answer:</strong> True</p><h2 id=6-4>6</h2><p>In a connected undirected graph with more than three vertices and all distinct edge weights, the two edges with the smallest weights will always be part of its Minimum Spanning Tree (MST).</p><p><strong>Answer:</strong> True</p><h1 id=grpas>GrPAs</h1><h2 id=1-5>1</h2><p>We are implementing Kruskal&rsquo;s algorithm because it&rsquo;s just a tad bit easier than Prim&rsquo;s algorithm.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>FiberLink</span>(wl):
</span></span><span style=display:flex><span>    sum, edges, component <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, [], {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> u, u_edges <span style=color:#f92672>in</span> wl<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>        component[u] <span style=color:#f92672>=</span> u
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> v, d <span style=color:#f92672>in</span> u_edges:
</span></span><span style=display:flex><span>            edges<span style=color:#f92672>.</span>append((d, u, v))
</span></span><span style=display:flex><span>    edges<span style=color:#f92672>.</span>sort()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> d, u, v <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> component[v] <span style=color:#f92672>==</span> component[u]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> d
</span></span><span style=display:flex><span>        c <span style=color:#f92672>=</span> component[u]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ckey, cval <span style=color:#f92672>in</span> component<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cval <span style=color:#f92672>==</span> c:
</span></span><span style=display:flex><span>                component[ckey] <span style=color:#f92672>=</span> component[v]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum
</span></span></code></pre></div><h2 id=2-5>2</h2><p>The shorted walk from <code>src</code> to <code>dst</code> while bouncing off the <code>bounce</code> node. We are using Bellman-Ford because simple is good.</p><p>We can find the shortest path from <code>bounce</code> to each of <code>src</code> and <code>dst</code> and then add up those two paths (both the path sequence and the weight).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_cost_walk</span>(wl, src, dest, bounce):
</span></span><span style=display:flex><span>    dist, parent <span style=color:#f92672>=</span> {}, {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> wl<span style=color:#f92672>.</span>keys():
</span></span><span style=display:flex><span>        dist[u] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e6</span> <span style=color:#75715e># close to infinity</span>
</span></span><span style=display:flex><span>    dist[bounce] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(len(wl)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> u, edges <span style=color:#f92672>in</span> wl<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> v, weight <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> dist[u] <span style=color:#f92672>+</span> weight <span style=color:#f92672>&lt;</span> dist[v]:
</span></span><span style=display:flex><span>                    dist[v] <span style=color:#f92672>=</span> dist[u] <span style=color:#f92672>+</span> weight
</span></span><span style=display:flex><span>                    parent[v] <span style=color:#f92672>=</span> u
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    path <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    revpath <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    distance <span style=color:#f92672>=</span> dist[src] <span style=color:#f92672>+</span> dist[dest]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> src <span style=color:#f92672>!=</span> bounce:
</span></span><span style=display:flex><span>        path<span style=color:#f92672>.</span>append(src)
</span></span><span style=display:flex><span>        src <span style=color:#f92672>=</span> parent[src]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    path<span style=color:#f92672>.</span>append(bounce)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> dest <span style=color:#f92672>!=</span> bounce:
</span></span><span style=display:flex><span>        revpath<span style=color:#f92672>.</span>append(dest)
</span></span><span style=display:flex><span>        dest <span style=color:#f92672>=</span> parent[dest]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> distance, path <span style=color:#f92672>+</span> revpath[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><h2 id=3-5>3</h2><p>Here again, we are using Bellman-Ford. Remember from the activity question answers that if there are any relaxations in the <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>t</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">n_{th}</annotation></semantics></math></span> iteration,
there exists a negative cycle in the graph.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>IsNegativeWeightCyclePresent</span>(wl):
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(wl)
</span></span><span style=display:flex><span>    dist <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    parent <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> wl:
</span></span><span style=display:flex><span>        dist[u] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e6</span>
</span></span><span style=display:flex><span>    dist[u] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e># the node to start with</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> u, edges <span style=color:#f92672>in</span> wl<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> v, weight <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> dist[u] <span style=color:#f92672>+</span> weight <span style=color:#f92672>&lt;</span> dist[v]:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>                    dist[v] <span style=color:#f92672>=</span> dist[u] <span style=color:#f92672>+</span> weight
</span></span><span style=display:flex><span>                    parent[v] <span style=color:#f92672>=</span> u
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span></code></pre></div><h1 id=ga>GA</h1><h2 id=1-6>1</h2><p>At each step of Dijkstra&rsquo;s algorithm, after a vertex has been processed, how does the algorithm determine which unvisited vertex to process next?</p><p>Answer: It picks the unvisited vertex that has the smallest current shortest distance from the source.</p><h2 id=2-6>2</h2><p>Which of the following statements correctly describes how the Bellman-Ford algorithm detects the presence of a negative cycle reachable from the source? Consider that V is the number of vertices in the graph.</p><p>Answer: If, during a Vth pass over all edges, any distance value can still be improved (i.e., an edge relaxation occurs).</p><h2 id=3-6>3</h2><p>A graph has 4 vertices (V1, V2, V3, V4) and the following edges:</p><ul><li>V1 â†’ V2 (weight = 2)</li><li>V2 â†’ V3 (weight = -3)</li><li>V3 â†’ V1 (weight = 0)</li><li>V1 â†’ V4 (weight = 5)</li></ul><p>If Bellman-Ford starts from V1, after running the algorithm for all necessary passes, how many vertices will have their shortest distance updated in the final (4-th) pass used for negative cycle detection?</p><p>Answer: 3</p><h2 id=4-5>4</h2><p>Consider any connected graph with 4 vertices and 6 edges, where all edge weights are distinct. In such a graph, the three edges with the smallest weights will always be part of its Minimum Spanning Tree (MST).</p><p>Answer: False</p><h2 id=5-5>5</h2><p>A graph can have a unique Minimum Spanning Tree (MST) only if all its edge weights are distinct</p><p>Answer: True</p><h2 id=6-5>6</h2><p>Suppose we run Prim&rsquo;s algorithm and Kruskal&rsquo;s algorithm on a graph G and these two algorithms
produce minimum-cost spanning trees <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_P</annotation></semantics></math></span> and <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">T_K</annotation></semantics></math></span>, respectively.</p><p>(I) <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_P</annotation></semantics></math></span> may be different from <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">T_K</annotation></semantics></math></span> if some pair of edges in G have the same weight.</p><p>(II) <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_P</annotation></semantics></math></span> is always the same as <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">T_K</annotation></semantics></math></span> if all edges in G have distinct weights.</p><p>Answer: Both (I) and (II) are correct.</p><h2 id=7>7</h2><p>Which one of the following can be the sequence of edges added, in that order, to create a minimum spanning tree using Kruskalâ€™s algorithm?</p><p>Answers:</p><ol><li>(a,b) (d,f) (b,f) (d,c) (d,e)</li><li>(a,b) (d,f) (d,c) (b,f) (d,e)</li><li>(d,f) (a,b) (d,c) (b,f) (d,e)</li></ol><ol start=5><li>(d,f) (a,b) (b,f) (d,c) (d,e)</li></ol><h2 id=8>8</h2><p>Consider the given weighted adjacency matrix <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span> for a complete undirected graph with vertex
set <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, 2, 3, 4\}</annotation></semantics></math></span>. Where <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w[i][j]</annotation></semantics></math></span>, <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo mathvariant="normal">â‰ </mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \neq j</annotation></semantics></math></span> in the matrix is the weight of the edge
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span>.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">w = \begin{pmatrix}
0 &amp; 1 &amp; 8 &amp; 1 &amp; 4 \\
1 &amp; 0 &amp; 12 &amp; 4 &amp; 9 \\
8 &amp; 12 &amp; 0 &amp; 7 &amp; 3 \\
1 &amp; 4 &amp; 7 &amp; 0 &amp; 2 \\
4 &amp; 9 &amp; 3 &amp; 2 &amp; 0
\end{pmatrix}</annotation></semantics></math></span><p>What is the weight of the minimum spanning tree for the given graph?</p><p>Answer: 7</p><h2 id=9>9</h2><p>Which of the following statement(s) is/are true about the spanning tree of a connected graph?</p><p>Answers:</p><ul><li>A spanning tree is a connected acyclic graph.</li><li>A spanning tree for an n vertex graph has exactly n-1 edges.</li><li>Adding an edge to a spanning tree must create a cycle.</li><li>In a spanning tree, every pair of nodes is connected by a unique path</li></ul><h2 id=10>10</h2><p>Consider the following weighted adjacency list WList for a directed and connected graph. What will be the path weight of the shortest path from 1 to 3?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>WList <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>#source: [(destination, weight),...]</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span>: [(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>10</span>), (<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2</span>: [(<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>2</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>3</span>: [(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>), (<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>4</span>: [(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>3</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>5</span>: [(<span style=color:#ae81ff>6</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>6</span>: [(<span style=color:#ae81ff>3</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>7</span>: [(<span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>), (<span style=color:#ae81ff>6</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>8</span>: [(<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Answer: 5</p><h2 id=11>11</h2><p>Consider a complete undirected graph with vertex set {0, 1, 2, 3, 4}. Every entry W[i][j] where iâ‰ j in the matrix W below is the weight of the edge from vertex i to vertex j.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">w = \begin{pmatrix}
0 &amp; 1 &amp; 8 &amp; 1 &amp; 4 \\
1 &amp; 0 &amp; 12 &amp; 4 &amp; 9 \\
8 &amp; 12 &amp; 0 &amp; 7 &amp; 3 \\
1 &amp; 4 &amp; 7 &amp; 0 &amp; 2 \\
4 &amp; 9 &amp; 3 &amp; 2 &amp; 0
\end{pmatrix}</annotation></semantics></math></span><p>Answer: 4</p><h2 id=12>12</h2><p>In the given graph, if we try to find the shortest path from node a to all other nodes using Dijkstra&rsquo;s algorithm, in what order do the nodes get included in the visited set?</p><p>Answer: a e d c b g f h</p><h2 id=13>13</h2><p>Consider the given graph. Which of the following is the correct sequence of edges added to the minimum spanning tree when Prim&rsquo;s algorithm is applied on this graph with 5 as the source vertex?</p><p>Answer: [(5,1),(1,2),(2,3),(3,4)]</p><h2 id=14>14</h2><p>In the context of the Floyd-Warshall algorithm, what does it mean if the distance matrix has a negative value in its diagonal?</p><p>Answer: The graph has a negative-weight cycle.</p><h2 id=15>15</h2><p>Consider the graph G given. Let
Î± denote the number of minimum spanning trees of G and
Î² denote the weight of such a minimum spanning tree. The value of
Î±+Î² is</p><p>Answer: 14</p></section><footer class=post-tags data-pagefind-meta=tags></footer></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>