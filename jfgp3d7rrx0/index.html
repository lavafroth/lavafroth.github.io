<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>secret note jfgp3d7rrx0 - lavafroth</title><meta name=description content='There will be an explanation for non-trivial questions.
Activity 1
1
Dijkstra&rsquo;s algorithm guarantees finding the shortest path from a single source to all other vertices under which of the following conditions?
Answer: All edge weights must be non-negative.
2
Consider an undirected graph with 5 vertices (V0,V1,V2,V3,V4)(V_0, V_1, V_2, V_3, V_4). At a certain point
in Dijkstra&rsquo;s algorithm (starting from V0V_0), the current tentative distances are:
dist={V0:0,V1:5,V2:3,V3:8,V4:10}dist = \{V_0:0, V_1:5, V_2:3, V_3:8, V_4:10\}. And the processed set is: {V0:True,V1:False,V2:False,V3:False,V4:False}\{V_0:True, 
V_1:False, V_2:False, V_3:False, V_4:False\}. Assuming the next step is to select an unvisited
vertex to mark as processed, which vertex will be chosen?'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/rss.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body><header><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2080"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a><nav><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../art/ aria-label=art style=--url:url(./art.svg)></a><a href=../index.xml aria-label=rss style=--url:url(./rss.svg)></a><nav></header><main><hgroup data-pagefind-body><p data-pagefind-ignore><time>Oct 28, 2025 | 13 minutes read</time></p><h1 data-pagefind-meta=title>secret note jfgp3d7rrx0</h1></hgroup><section class=post-content data-pagefind-body><p>There will be an explanation for non-trivial questions.</p><h1 id=activity-1>Activity 1</h1><h2 id=1>1</h2><p>Dijkstra&rsquo;s algorithm guarantees finding the shortest path from a single source to all other vertices under which of the following conditions?</p><p><strong>Answer:</strong> All edge weights must be non-negative.</p><h2 id=2>2</h2><p>Consider an undirected graph with 5 vertices <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>V</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>3</mn></msub><mo separator="true">,</mo><msub><mi>V</mi><mn>4</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(V_0, V_1, V_2, V_3, V_4)</annotation></semantics></math></span>. At a certain point
in Dijkstra&rsquo;s algorithm (starting from <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">V_0</annotation></semantics></math></span>), the current tentative distances are:
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>V</mi><mn>0</mn></msub><mo>:</mo><mn>0</mn><mo separator="true">,</mo><msub><mi>V</mi><mn>1</mn></msub><mo>:</mo><mn>5</mn><mo separator="true">,</mo><msub><mi>V</mi><mn>2</mn></msub><mo>:</mo><mn>3</mn><mo separator="true">,</mo><msub><mi>V</mi><mn>3</mn></msub><mo>:</mo><mn>8</mn><mo separator="true">,</mo><msub><mi>V</mi><mn>4</mn></msub><mo>:</mo><mn>10</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">dist = \{V_0:0, V_1:5, V_2:3, V_3:8, V_4:10\}</annotation></semantics></math></span>. And the processed set is: <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>V</mi><mn>0</mn></msub><mo>:</mo><mi>T</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>V</mi><mn>1</mn></msub><mo>:</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>V</mi><mn>2</mn></msub><mo>:</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>V</mi><mn>3</mn></msub><mo>:</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo separator="true">,</mo><msub><mi>V</mi><mn>4</mn></msub><mo>:</mo><mi>F</mi><mi>a</mi><mi>l</mi><mi>s</mi><mi>e</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{V_0:True, 
V_1:False, V_2:False, V_3:False, V_4:False\}</annotation></semantics></math></span>. Assuming the next step is to select an unvisited
vertex to mark as processed, which vertex will be chosen?</p><p><strong>Answer:</strong> <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>V</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">V_2</annotation></semantics></math></span></p><p>Explanation: Dijkstra will choose the next unprocessed vertex with the least weight.</p><h2 id=3>3</h2><p>Which of the following components is/are essential for a standard implementation of Dijkstra&rsquo;s algorithm?</p><p><strong>Answers:</strong></p><ul><li>A way to store the tentative shortest distance to each vertex.</li><li>A set to keep track of vertices whose shortest paths have been finalized.</li><li>A mechanism to select the unvisited vertex with the smallest current distance.</li></ul><h2 id=4>4</h2><p>Consider an undirected graph with vertices S, A, B, C, D and edges with weights: S-A (4), S-B (2), A-C (5), B-A (1), B-D (8), C-D (3). If Dijkstra&rsquo;s algorithm starts from vertex &lsquo;S&rsquo;, what is the value of dist[D] immediately after vertex &lsquo;A&rsquo; has been marked as processed?</p><p><strong>Answer:</strong> 10</p><h2 id=5>5</h2><p>When Dijkstra&rsquo;s algorithm is examining an edge (u, v) from a newly processed vertex u , and it finds that the path source -> &mldr; -> u -> v offers a shorter route to v than its currently recorded shortest distance ( dist[v] ), what is the direct consequence for dist[v] and v &rsquo;s status?</p><p><strong>Answer:</strong>
dist[v] is updated, and v&rsquo;s status remains un-processed, awaiting its turn in a future selection step</p><h2 id=6>6</h2><p>Given a weighted graph where weights of all edges are unique, there is always a unique shortest path from a source to destination in such a graph.</p><p><strong>Answer:</strong> False</p><p>Explanation: There can be multiple sequence of edges from vertex <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span> to <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span> representing the shortest path. The only necessary property is that the sum of the weights on these edges is the least.</p><h1 id=activity-2>Activity 2</h1><h2 id=1-1>1</h2><p>What is a fundamental capability of the Bellman-Ford algorithm that distinguishes it from Dijkstra&rsquo;s algorithm for finding shortest paths?</p><p><strong>Answer:</strong> It is able to correctly find shortest paths in graphs containing negative edge weights.</p><h2 id=2-1>2</h2><p>For a graph with 7 vertices and 10 edges, if it contains no negative cycles, what is the minimum number of passes over all edges that the Bellman-Ford algorithm needs to perform to guarantee that all shortest path distances are finalized?</p><p><strong>Answer:</strong> 6</p><h2 id=3-1>3</h2><p>Consider the following directed graph. If the Bellman-Ford algorithm starts from vertex &lsquo;S&rsquo;, what are the shortest distances to vertices &lsquo;A&rsquo;, &lsquo;B&rsquo;, and &lsquo;C&rsquo; (in that order: dist[A] , dist[B] , dist[C] ) after exactly 2 passes over all edges?</p><p><strong>Answer:</strong> 6</p><p>Explanation: It takes <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n-1</annotation></semantics></math></span> iterations for a graph with <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span> edges to stabilize via Bellman Ford if there are no negative edges.</p><p>If the graph stabilizes further from the <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span> iteration onwards, it contains negative cycles.</p><h2 id=4-1>4</h2><p>When Bellman-Ford performs a pass over all edges, does the order in which edges are relaxed within that single pass affect the final shortest path distances after all V−1 passes (assuming no negative cycles are present)?</p><p><strong>Answer:</strong> No, the order of edge relaxation within a pass does not affect the final distances after all V−1 passes.</p><h2 id=5-1>5</h2><p>Which of the following statements accurately describe properties or uses of the Bellman-Ford algorithm?</p><p><strong>Answers:</strong></p><ul><li>If a negative cycle is detected, the algorithm reports its presence and may not produce valid shortest paths for affected vertices.</li><li>The algorithm is suitable for distributed shortest path computation.</li></ul><h2 id=6-1>6</h2><p>Given a graph where all edges have positive weights, the shortest path produced by Dijkstra&rsquo;s and Bellman Ford algorithm may be different but path weight would be same.</p><p><strong>Answer:</strong> True</p><h1 id=activity-3>Activity 3</h1><h2 id=1-2>1</h2><p>What type of shortest path problem is the Floyd-Warshall algorithm designed to solve?</p><p><strong>Answer:</strong> All-pairs shortest paths in graphs with negative edge weights or positive edge weights (but no negative cycles).</p><h2 id=2-2>2</h2><p>The core update rule in Floyd-Warshall is</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo>+</mo><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mi>k</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</annotation></semantics></math></span><p>What does the variable k fundamentally represent in this context?</p><p><strong>Answer:</strong> An intermediate vertex that might lie on a shortest path from i to j</p><h2 id=3-2>3</h2><p>What is the time complexity of the Floyd-Warshall algorithm for a graph with N vertices?</p><p><strong>Answer:</strong> <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N^3)</annotation></semantics></math></span></p><h2 id=4-2>4</h2><p>How does the Floyd-Warshall algorithm detect the presence of a negative weight cycle in the graph?</p><p><strong>Answer:</strong> By observing if any dist[i][i] (distance from a vertex to itself) becomes negative after all iterations</p><h2 id=5-2>5</h2><p>Consider a graph with 3 vertices {1, 2, 3}. The initial distance matrix dist is given as: dist[1][1] = 0, dist[1][2] = 2, dist[1][3] = 7 dist[2][1] = inf, dist[2][2] = 0, dist[2][3] = 3 dist[3][1] = inf, dist[3][2] = inf, dist[3][3] = 0</p><p>What is the value of dist[1][3] after the iteration where k = 2 is considered as the intermediate vertex?</p><p><strong>Answer:</strong> 5</p><h2 id=6-2>6</h2><p>Consider a graph with 3 vertices {1, 2, 3}. The initial distance matrix dist is set up. dist[1][1]=0, dist[1] [2]=5, dist[1][3]=inf dist[2][1]=inf, dist[2][2]=0, dist[2][3]=2 dist[3][1]=inf, dist[3] [2]=inf, dist[3][3]=0</p><p>After all iterations of the Floyd-Warshall algorithm, what will be the value of <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">[</mo><mn>3</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">dist[3][1]</annotation></semantics></math></span>?</p><p><strong>Answer:</strong> inf</p><p>Explanation: The distance of 3 to 1 is never updated.</p><h1 id=activity-4>Activity 4</h1><h2 id=1-3>1</h2><p>Prim&rsquo;s algorithm builds the Minimum Spanning Tree (MST) by iteratively adding edges. At each step, which type of edge does it always select?</p><p><strong>Answer:</strong> The edge with the smallest weight that connects a vertex already in the MST to a vertex not yet in the MST</p><h2 id=2-3>2</h2><p>Consider the following undirected graph. If Prim&rsquo;s algorithm starts from vertex &lsquo;A&rsquo;, what is the total weight of the Minimum Spanning Tree (MST) it finds?</p><p>Graph: A-B (4), A-C (2), B-C (5), B-D (10), C-D (3), C-E (7), D-E (1)</p><p><strong>Answer:</strong> 10</p><h2 id=3-3>3</h2><p>A connected, undirected graph has 6 vertices and 7 edges. If Prim&rsquo;s algorithm is used to find its Minimum Spanning Tree, how many edges will be included in the final MST?</p><p><strong>Answer:</strong> 5</p><h2 id=4-3>4</h2><p>When is the Minimum Spanning Tree (MST) of a connected, weighted graph guaranteed to be unique?</p><p><strong>Answer:</strong> If all edge weights in the graph are distinct.</p><h2 id=5-3>5</h2><p>Suppose Prim&rsquo;s algorithm has constructed an MST for a graph. If the weight of an edge not currently in the MST is decreased, will the existing MST always change?</p><p><strong>Answer:</strong> Not necessarily; the MST will change only if the decreased edge becomes the new minimum edge across some cut that was previously crossed by a different (heavier) MST edge.</p><h2 id=6-3>6</h2><p>If Prim&rsquo;s algorithm has generated a Minimum Spanning Tree (MST) for a connected graph, the unique path between any two vertices within that MST is always the shortest path between those two vertices in the original graph</p><p><strong>Answer:</strong> False</p><h1 id=activity-5>Activity 5</h1><h2 id=1-4>1</h2><p>Which of the following statements about how Kruskal&rsquo;s algorithm constructs the MST are true?</p><p><strong>Answer:</strong> (Yes there is only one I think is correct)</p><ul><li>It adds an edge only if it connects two vertices that belong to different existing components.</li></ul><h2 id=2-4>2</h2><p>A graph has 5 vertices {V1, V2, V3, V4, V5}. Kruskal&rsquo;s algorithm is applied. Initially, each vertex is in its own set: {V1}, {V2}, {V3}, {V4}, {V5}. Consider the following sequence of edges processed by Kruskal&rsquo;s algorithm:</p><p>(V1, V2) - weight 2
(V3, V4) - weight 3
(V1, V3) - weight 4
(V2, V4) - weight 5
(V5, V2) - weight 6</p><p>How many distinct connected components are there after these 5 edges have been processed and decisions made?</p><p><strong>Answer:</strong> 1</p><h2 id=3-4>3</h2><p>If Kruskal&rsquo;s algorithm considers an edge e and decides not to include it in the MST, what is the precise reason for this exclusion?</p><p><strong>Answer:</strong> Adding edge e would connect two vertices that are already in the same connected component within the set of edges already chosen for the MST.</p><h2 id=4-4>4</h2><p>A graph has 7 vertices and consists of 3 distinct connected components. Kruskal&rsquo;s algorithm is executed on this graph. Assuming all components are non-empty and connected internally, how many edges will Kruskal&rsquo;s algorithm include in the resulting Minimum Spanning Forest (MSF)?</p><p><strong>Answer:</strong> 4</p><h2 id=5-4>5</h2><p>If Kruskal&rsquo;s algorithm rejects an edge e (meaning e is not included in the MST), it implies that e is the heaviest edge in any cycle that e forms with edges already selected for the MST.</p><p><strong>Answer:</strong> True</p><h2 id=6-4>6</h2><p>In a connected undirected graph with more than three vertices and all distinct edge weights, the two edges with the smallest weights will always be part of its Minimum Spanning Tree (MST).</p><p><strong>Answer:</strong> True</p><h1 id=grpas>GrPAs</h1><h2 id=1-5>1</h2><p>We are implementing Kruskal&rsquo;s algorithm because it&rsquo;s just a tad bit easier than Prim&rsquo;s algorithm.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>FiberLink</span>(wl):
</span></span><span style=display:flex><span>    sum, edges, component <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, [], {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> u, u_edges <span style=color:#f92672>in</span> wl<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>        component[u] <span style=color:#f92672>=</span> u
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> v, d <span style=color:#f92672>in</span> u_edges:
</span></span><span style=display:flex><span>            edges<span style=color:#f92672>.</span>append((d, u, v))
</span></span><span style=display:flex><span>    edges<span style=color:#f92672>.</span>sort()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> d, u, v <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> component[v] <span style=color:#f92672>==</span> component[u]:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>        sum <span style=color:#f92672>+=</span> d
</span></span><span style=display:flex><span>        c <span style=color:#f92672>=</span> component[u]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> ckey, cval <span style=color:#f92672>in</span> component<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> cval <span style=color:#f92672>==</span> c:
</span></span><span style=display:flex><span>                component[ckey] <span style=color:#f92672>=</span> component[v]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum
</span></span></code></pre></div><h2 id=2-5>2</h2><p>The shorted walk from <code>src</code> to <code>dst</code> while bouncing off the <code>bounce</code> node. We are using Bellman-Ford because simple is good.</p><p>We can find the shortest path from <code>bounce</code> to each of <code>src</code> and <code>dst</code> and then add up those two paths (both the path sequence and the weight).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_cost_walk</span>(wl, src, dest, bounce):
</span></span><span style=display:flex><span>    dist, parent <span style=color:#f92672>=</span> {}, {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> wl<span style=color:#f92672>.</span>keys():
</span></span><span style=display:flex><span>        dist[u] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e6</span> <span style=color:#75715e># close to infinity</span>
</span></span><span style=display:flex><span>    dist[bounce] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> _ <span style=color:#f92672>in</span> range(len(wl)):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> u, edges <span style=color:#f92672>in</span> wl<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> v, weight <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> dist[u] <span style=color:#f92672>+</span> weight <span style=color:#f92672>&lt;</span> dist[v]:
</span></span><span style=display:flex><span>                    dist[v] <span style=color:#f92672>=</span> dist[u] <span style=color:#f92672>+</span> weight
</span></span><span style=display:flex><span>                    parent[v] <span style=color:#f92672>=</span> u
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    path <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    revpath <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    distance <span style=color:#f92672>=</span> dist[src] <span style=color:#f92672>+</span> dist[dest]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> src <span style=color:#f92672>!=</span> bounce:
</span></span><span style=display:flex><span>        path<span style=color:#f92672>.</span>append(src)
</span></span><span style=display:flex><span>        src <span style=color:#f92672>=</span> parent[src]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    path<span style=color:#f92672>.</span>append(bounce)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> dest <span style=color:#f92672>!=</span> bounce:
</span></span><span style=display:flex><span>        revpath<span style=color:#f92672>.</span>append(dest)
</span></span><span style=display:flex><span>        dest <span style=color:#f92672>=</span> parent[dest]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> distance, path <span style=color:#f92672>+</span> revpath[::<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><h2 id=3-5>3</h2><p>Here again, we are using Bellman-Ford. Remember from the activity question answers that if there are any relaxations in the <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mrow><mi>t</mi><mi>h</mi></mrow></msub></mrow><annotation encoding="application/x-tex">n_{th}</annotation></semantics></math></span> iteration,
there exists a negative cycle in the graph.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>IsNegativeWeightCyclePresent</span>(wl):
</span></span><span style=display:flex><span>    n <span style=color:#f92672>=</span> len(wl)
</span></span><span style=display:flex><span>    dist <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    parent <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> wl:
</span></span><span style=display:flex><span>        dist[u] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1e6</span>
</span></span><span style=display:flex><span>    dist[u] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#75715e># the node to start with</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(n):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> u, edges <span style=color:#f92672>in</span> wl<span style=color:#f92672>.</span>items():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> v, weight <span style=color:#f92672>in</span> edges:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> dist[u] <span style=color:#f92672>+</span> weight <span style=color:#f92672>&lt;</span> dist[v]:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>==</span> n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>                    dist[v] <span style=color:#f92672>=</span> dist[u] <span style=color:#f92672>+</span> weight
</span></span><span style=display:flex><span>                    parent[v] <span style=color:#f92672>=</span> u
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>False</span>
</span></span></code></pre></div><h1 id=ga>GA</h1><h2 id=1-6>1</h2><p>At each step of Dijkstra&rsquo;s algorithm, after a vertex has been processed, how does the algorithm determine which unvisited vertex to process next?</p><p>Answer: It picks the unvisited vertex that has the smallest current shortest distance from the source.</p><h2 id=2-6>2</h2><p>Which of the following statements correctly describes how the Bellman-Ford algorithm detects the presence of a negative cycle reachable from the source? Consider that V is the number of vertices in the graph.</p><p>Answer: If, during a Vth pass over all edges, any distance value can still be improved (i.e., an edge relaxation occurs).</p><h2 id=3-6>3</h2><p>A graph has 4 vertices (V1, V2, V3, V4) and the following edges:</p><ul><li>V1 → V2 (weight = 2)</li><li>V2 → V3 (weight = -3)</li><li>V3 → V1 (weight = 0)</li><li>V1 → V4 (weight = 5)</li></ul><p>If Bellman-Ford starts from V1, after running the algorithm for all necessary passes, how many vertices will have their shortest distance updated in the final (4-th) pass used for negative cycle detection?</p><p>Answer: 3</p><h2 id=4-5>4</h2><p>Consider any connected graph with 4 vertices and 6 edges, where all edge weights are distinct. In such a graph, the three edges with the smallest weights will always be part of its Minimum Spanning Tree (MST).</p><p>Answer: False</p><h2 id=5-5>5</h2><p>A graph can have a unique Minimum Spanning Tree (MST) only if all its edge weights are distinct</p><p>Answer: True</p><h2 id=6-5>6</h2><p>Suppose we run Prim&rsquo;s algorithm and Kruskal&rsquo;s algorithm on a graph G and these two algorithms
produce minimum-cost spanning trees <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_P</annotation></semantics></math></span> and <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">T_K</annotation></semantics></math></span>, respectively.</p><p>(I) <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_P</annotation></semantics></math></span> may be different from <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">T_K</annotation></semantics></math></span> if some pair of edges in G have the same weight.</p><p>(II) <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>P</mi></msub></mrow><annotation encoding="application/x-tex">T_P</annotation></semantics></math></span> is always the same as <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>K</mi></msub></mrow><annotation encoding="application/x-tex">T_K</annotation></semantics></math></span> if all edges in G have distinct weights.</p><p>Answer: Both (I) and (II) are correct.</p><h2 id=7>7</h2><p>Which one of the following can be the sequence of edges added, in that order, to create a minimum spanning tree using Kruskal’s algorithm?</p><p>Answers:</p><ol><li>(a,b) (d,f) (b,f) (d,c) (d,e)</li><li>(a,b) (d,f) (d,c) (b,f) (d,e)</li><li>(d,f) (a,b) (d,c) (b,f) (d,e)</li></ol><ol start=5><li>(d,f) (a,b) (b,f) (d,c) (d,e)</li></ol><h2 id=8>8</h2><p>Consider the given weighted adjacency matrix <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span> for a complete undirected graph with vertex
set <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>3</mn><mo separator="true">,</mo><mn>4</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{0, 1, 2, 3, 4\}</annotation></semantics></math></span>. Where <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">w[i][j]</annotation></semantics></math></span>, <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo mathvariant="normal">≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i \neq j</annotation></semantics></math></span> in the matrix is the weight of the edge
<span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(i,j)</annotation></semantics></math></span>.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">w = \begin{pmatrix}
0 &amp; 1 &amp; 8 &amp; 1 &amp; 4 \\
1 &amp; 0 &amp; 12 &amp; 4 &amp; 9 \\
8 &amp; 12 &amp; 0 &amp; 7 &amp; 3 \\
1 &amp; 4 &amp; 7 &amp; 0 &amp; 2 \\
4 &amp; 9 &amp; 3 &amp; 2 &amp; 0
\end{pmatrix}</annotation></semantics></math></span><p>What is the weight of the minimum spanning tree for the given graph?</p><p>Answer: 7</p><h2 id=9>9</h2><p>Which of the following statement(s) is/are true about the spanning tree of a connected graph?</p><p>Answers:</p><ul><li>A spanning tree is a connected acyclic graph.</li><li>A spanning tree for an n vertex graph has exactly n-1 edges.</li><li>Adding an edge to a spanning tree must create a cycle.</li><li>In a spanning tree, every pair of nodes is connected by a unique path</li></ul><h2 id=10>10</h2><p>Consider the following weighted adjacency list WList for a directed and connected graph. What will be the path weight of the shortest path from 1 to 3?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>WList <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>#source: [(destination, weight),...]</span>
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>1</span>: [(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>10</span>), (<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>8</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>2</span>: [(<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>2</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>3</span>: [(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>), (<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>4</span>: [(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>3</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>5</span>: [(<span style=color:#ae81ff>6</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>6</span>: [(<span style=color:#ae81ff>3</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>2</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>7</span>: [(<span style=color:#ae81ff>2</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>4</span>), (<span style=color:#ae81ff>6</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)],
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>8</span>: [(<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>1</span>)]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Answer: 5</p><h2 id=11>11</h2><p>Consider a complete undirected graph with vertex set {0, 1, 2, 3, 4}. Every entry W[i][j] where i≠j in the matrix W below is the weight of the edge from vertex i to vertex j.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>w</mi><mo>=</mo><mrow><mo fence="true">(</mo><mtable rowspacing="0.16em" columnalign="center center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>8</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>12</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>9</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">w = \begin{pmatrix}
0 &amp; 1 &amp; 8 &amp; 1 &amp; 4 \\
1 &amp; 0 &amp; 12 &amp; 4 &amp; 9 \\
8 &amp; 12 &amp; 0 &amp; 7 &amp; 3 \\
1 &amp; 4 &amp; 7 &amp; 0 &amp; 2 \\
4 &amp; 9 &amp; 3 &amp; 2 &amp; 0
\end{pmatrix}</annotation></semantics></math></span><p>Answer: 4</p><h2 id=12>12</h2><p>In the given graph, if we try to find the shortest path from node a to all other nodes using Dijkstra&rsquo;s algorithm, in what order do the nodes get included in the visited set?</p><p>Answer: a e d c b g f h</p><h2 id=13>13</h2><p>Consider the given graph. Which of the following is the correct sequence of edges added to the minimum spanning tree when Prim&rsquo;s algorithm is applied on this graph with 5 as the source vertex?</p><p>Answer: [(5,1),(1,2),(2,3),(3,4)]</p><h2 id=14>14</h2><p>In the context of the Floyd-Warshall algorithm, what does it mean if the distance matrix has a negative value in its diagonal?</p><p>Answer: The graph has a negative-weight cycle.</p><h2 id=15>15</h2><p>Consider the graph G given. Let
α denote the number of minimum spanning trees of G and
β denote the weight of such a minimum spanning tree. The value of
α+β is</p><p>Answer: 14</p></section><footer class=post-tags data-pagefind-meta=tags></footer></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>