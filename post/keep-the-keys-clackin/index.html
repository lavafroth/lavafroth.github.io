<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Keep the Keys Clackin' - lavafroth</title><meta name=description content='This is the second post in a series of posts I&rsquo;m writing for Google Summer of Code.
Each post covers a separate topic.
While the previous posts might have given you an overview of ideas, this post will delve
into more technical details. I highly recommend reading the previous posts because I will
refer to them from time to time.
Let&rsquo;s begin with why we chose EBNF grammar in pest.rs instead of regular expressions.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><noscript><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/noscript.min.css></noscript><link rel=prefetch as=font href=https://lavafroth.is-a.dev/LeagueGothic.ttf><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body class=not-ready data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/>lavafroth</a></h1><svg class="btn-dark" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 60 60" preserveAspectRatio="xMinYMin meet"><path class="circle" d="M30 16c7.73.0 14 6.27 14 14 0 3.81-1.53 7.27-4 9.8-2.54 2.59-6.08 4.2-10 4.2-7.73.0-14-6.27-14-14 0-7.73 6.27-14 14-14z"/><g class="rays" data-svg-origin="30 30"><line class="line" x1="30" y1="11" x2="30" y2="7"/><line class="line" x1="43.44" y1="16.57" x2="46.26" y2="13.74"/><line class="line" x1="49" y1="30" x2="53" y2="30"/><line class="line" x1="43.43" y1="43.44" x2="46.26" y2="46.26"/><line class="line" x1="30" y1="49" x2="30" y2="53"/><line class="line" x1="16.56" y1="43.43" x2="13.74" y2="46.26"/><line class="line" x1="11" y1="30" x2="7" y2="30"/><line class="line" x1="16.57" y1="16.56" x2="13.74" y2="13.74"/></g></svg><div class=space></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><script>const bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>(bodyClx.toggle("dark",e),localStorage.setItem("dark",e));setDark(darkVal?darkVal==="true":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",({matches:e})=>setDark(e))</script></header><main class=main><article class=post-single><header class=post-title><p><time>May 27, 2024 | 5 minutes read</time></p><h1 data-pagefind-meta=title>Keep the Keys Clackin'</h1></header><section class=post-content data-pagefind-body><p>This is the second post in a series of posts I&rsquo;m writing for Google Summer of Code.
Each post covers a separate topic.
While the previous posts might have given you an overview of ideas, this post will delve
into more technical details. I highly recommend reading the previous posts because I will
refer to them from time to time.</p><p>Let&rsquo;s begin with why we chose EBNF grammar in <a href=https://pest.rs>pest.rs</a> instead of regular expressions.</p><h1 id=why-ebnf>Why EBNF?</h1><p>Let&rsquo;s say we have the following regular expression to match any line that starts with an <em>&ldquo;a&rdquo;</em> and ends
with a <em>&ldquo;e&rdquo;</em>:</p><pre tabindex=0><code class=language-regex data-lang=regex>a.*e
</code></pre><p>The dot star matches any character any number of times.</p><p>Let&rsquo;s say we supply a word <em>&ldquo;apple&rdquo;</em> for this regex to match.
Intuitively we can conclude that the regular expression will match but we often misunderstand how the matching
happens. The regex engine will simply match as much as it can, that is, the <code>.*</code> will match upto and
including the last <em>&ldquo;e&rdquo;</em>. Once it realizes that there are no characters left, it backtracks the <code>.*</code> to match slightly less
upto the <em>&ldquo;l&rdquo;</em> so that it can match the <em>&ldquo;e&rdquo;</em>.</p><p><img src=../../swhkd-regex.gif alt></p><p>This backtracking causes the algorithm to have an exponential time complexity. We want to build a fast parser, one that doesn&rsquo;t
hopefully get throttled by large files or multiple imports. The Extended Backus-Naur Form (EBNF) grammar in <em>pest.rs</em> follows a simple
greedy matching strategy which gives it a rather fast linear time complexity at the cost of us having to be a little bit more careful
while defining our expressions.</p><h1 id=keys>Keys</h1><p>According to SWHKD&rsquo;s definition of bindings, a keybind declaration must at least be a regular key.
This means, there&rsquo;s technically nothing stopping you from having a binding to a keypress like <code>a</code> that runs a command
to annoy the user with notifications.</p><pre tabindex=0><code>a
  notify-send &#39;LOL you pressed a!&#39;
</code></pre><p>However, generally keys are used in conjunction with modifiers prefixed before them.</p><p>From our general intuition, we might be able to conclude that a regular key must contain the ASCII alphanumeric characters,
symbols and control characters like backspace, enter, etc.</p><p>Recall from the previous post that our grammar supports shorthands delimited by curly braces and commas.
We also noted that certain keys inside these shorthands must be different from their counterparts outside shorthands.</p><p>The most obvious example is specifying a literal curly brace. Inside a shorthand, we have to escape the keys
with a backslash. Thus, <code>{</code> has to be written as <code>\{</code> inside shorthands.</p><p>To respect the difference between these two contexts, keys inside shorthands are modeled differently from those outside.</p><p>We start by defining what gets denied or allowed in shorthands.</p><pre tabindex=0><code>shorthand_bounds =  { &#34;{&#34; | &#34;}&#34; }
shorthand_deny  = { NEWLINE | shorthand_bounds | &#34;,&#34; | &#34;-&#34; }
shorthand_allow = { &#34;\\,&#34; | &#34;\\\\&#34; | &#34;\\{&#34; | &#34;\\}&#34; | &#34;\\-&#34; }
</code></pre><p>Now we will define a key to be used in a regular context.</p><pre tabindex=0><code>key = { ^&#34;enter&#34; | ^&#34;return&#34; | ASCII_ALPHANUMERIC }
key_normal =  { send? ~ on_release? ~ (key | &#34;,&#34; | &#34;-&#34;) }
</code></pre><p>You may ignore the <code>send</code> and <code>on_release</code> attributes for now but that is the
general definition of keys in the grammar.</p><pre tabindex=0><code>key_in_shorthand = {
 !shorthand_deny ~ send? ~ on_release? ~ (shorthand_allow | key)
}
</code></pre><p>In case of keys in a shorthand, we first make sure that it does not match keys denied in the context of
a shorthand (<code>!shorthand_deny</code>). Ignoring the attributes again, we match the allowed escaped versions of
the keys denied earlier (<code>shorthand_allow</code>) or any other regular key that does not need escaping.</p><p>We had also talked about a convenience features that allowed us to specify a range using dashes.
Since they are meant to be used inside shorthands, we reuse the <code>key_in_shorthand</code> expression to define
a key range like so:</p><pre tabindex=0><code>key_range = { key_in_shorthand ~ &#34;-&#34; ~ key_in_shorthand }
</code></pre><p>We use a blanket expression for building the overall shorthand expression called <code>key_or_range</code>. It does
exactly what it says, it is either a bare key or a dashed range in a shorthand context.</p><pre tabindex=0><code>key_or_range = _{ key_range | key_in_shorthand }
</code></pre><p>Note the use of the underscore while defining the grammar. This allows us to reference the expression without
needlessly exposing it to the code side.</p><p>We will now slowly build a shorthand from the expressions defined so far.
Let&rsquo;s think through what makes up a shorthand, starting from the outside.</p><p>A shorthand must begin and end in opening and closing curly braces respectively.</p><pre tabindex=0><code>shorthand = {
    &#34;{&#34;
    ~ // ...
    ~ &#34;}&#34;
}
</code></pre><p>When does a shorthand make sense to use? Well, we generally use them to define two or more bindings succinctly.</p><p>Therefore, we can dedeuce the possible expressions that a shorthand may begin with.
These are as follows:</p><table><thead><tr><th>first</th><th>second</th><th>example</th></tr></thead><tbody><tr><td>key</td><td>key</td><td><code>{a,b}</code></td></tr><tr><td>key</td><td>range</td><td><code>{a,b-c}</code></td></tr><tr><td></td><td>range</td><td><code>{a-c}</code></td></tr></tbody></table><p>We can model these three cases in the grammar like so:</p><pre tabindex=0><code>(key_in_shorthand ~ &#34;,&#34; ~ key_in_shorthand)
| (key_in_shorthand ~ &#34;,&#34; ~ key_range)
| key_range
</code></pre><p>These starting expressions can be followed by one or more keys or ranges. This is where the blanket expression <code>key_or_range</code> we defined
earlier make our lives easy. We can also make the above expression a little concise by abusing the blanket expression.</p><p>You see, for the first two possibilities, we are essentially saying that it needs to be a <code>key_in_shorthand</code>, a comma
and <em>either another key or a range</em>. So those two can boil down to use a <code>key_or_range</code> after the comma.</p><pre tabindex=0><code>(key_in_shorthand ~ &#34;,&#34; ~ key_or_range)
| key_range
</code></pre><p>Putting it all together, we get the following expression for a shorthand.</p><pre tabindex=0><code>shorthand = {
    &#34;{&#34;
    ~ ((key_in_shorthand ~ &#34;,&#34; ~ key_or_range) | key_range)
    ~ (&#34;,&#34; ~ key_or_range)*
    ~ &#34;}&#34;
}
</code></pre><p>Here <code>("," ~ key_or_range)*</code> represents the zero or more keys or ranges that the user may supply after the starting sequence.</p><p>That&rsquo;s all for today, I hope my explanation was not too convoluted. In the next post, I will talk about the <code>send</code> and the <code>on_release</code>
attributes that describe the timing of a keypress and how we handle the grammar for them.</p><p>Talk to you then!</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/timing-is-key/><span>←</span><span>Timing is Key: A Tale of Keystrokes and Timings</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/2-afternoons-2-languages-2-tuis/><span>2 Afternoons, 2 Languages, 2 TUIs</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>