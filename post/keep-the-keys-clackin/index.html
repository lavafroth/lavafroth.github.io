<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Keep the Keys Clackin' - lavafroth</title><meta name=description content='This is the second post in a series of posts I&rsquo;m writing for Google Summer of Code.
Each post covers a separate topic.
While the previous posts might have given you an overview of ideas, this post will delve
into more technical details. I highly recommend reading the previous posts because I will
refer to them from time to time.
Let&rsquo;s begin with why we chose EBNF grammar in pest.rs instead of regular expressions.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/rss.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body><header><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2080"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a><nav><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><a href=../../index.xml aria-label=rss style=--url:url(./rss.svg)></a><nav></header><main><hgroup data-pagefind-body><p data-pagefind-ignore><time>May 27, 2024 | 5 minutes read</time></p><h1 data-pagefind-meta=title>Keep the Keys Clackin'</h1></hgroup><section class=post-content data-pagefind-body><p>This is the second post in a series of posts I&rsquo;m writing for Google Summer of Code.
Each post covers a separate topic.
While the previous posts might have given you an overview of ideas, this post will delve
into more technical details. I highly recommend reading the previous posts because I will
refer to them from time to time.</p><p>Let&rsquo;s begin with why we chose EBNF grammar in <a href=https://pest.rs>pest.rs</a> instead of regular expressions.</p><h1 id=why-ebnf>Why EBNF?</h1><p>Let&rsquo;s say we have the following regular expression to match any line that starts with an <em>&ldquo;a&rdquo;</em> and ends
with a <em>&ldquo;e&rdquo;</em>:</p><pre tabindex=0><code class=language-regex data-lang=regex>a.*e
</code></pre><p>The dot star matches any character any number of times.</p><p>Let&rsquo;s say we supply a word <em>&ldquo;apple&rdquo;</em> for this regex to match.
Intuitively we can conclude that the regular expression will match but we often misunderstand how the matching
happens. The regex engine will simply match as much as it can, that is, the <code>.*</code> will match upto and
including the last <em>&ldquo;e&rdquo;</em>. Once it realizes that there are no characters left, it backtracks the <code>.*</code> to match slightly less
upto the <em>&ldquo;l&rdquo;</em> so that it can match the <em>&ldquo;e&rdquo;</em>.</p><p><img src=../../swhkd-regex.gif alt></p><p>This backtracking causes the algorithm to have an exponential time complexity. We want to build a fast parser, one that doesn&rsquo;t
hopefully get throttled by large files or multiple imports. The Extended Backus-Naur Form (EBNF) grammar in <em>pest.rs</em> follows a simple
greedy matching strategy which gives it a rather fast linear time complexity at the cost of us having to be a little bit more careful
while defining our expressions.</p><h1 id=keys>Keys</h1><p>According to SWHKD&rsquo;s definition of bindings, a keybind declaration must at least be a regular key.
This means, there&rsquo;s technically nothing stopping you from having a binding to a keypress like <code>a</code> that runs a command
to annoy the user with notifications.</p><pre tabindex=0><code>a
  notify-send &#39;LOL you pressed a!&#39;
</code></pre><p>However, generally keys are used in conjunction with modifiers prefixed before them.</p><p>From our general intuition, we might be able to conclude that a regular key must contain the ASCII alphanumeric characters,
symbols and control characters like backspace, enter, etc.</p><p>Recall from the previous post that our grammar supports shorthands delimited by curly braces and commas.
We also noted that certain keys inside these shorthands must be different from their counterparts outside shorthands.</p><p>The most obvious example is specifying a literal curly brace. Inside a shorthand, we have to escape the keys
with a backslash. Thus, <code>{</code> has to be written as <code>\{</code> inside shorthands.</p><p>To respect the difference between these two contexts, keys inside shorthands are modeled differently from those outside.</p><p>We start by defining what gets denied or allowed in shorthands.</p><pre tabindex=0><code>shorthand_bounds =  { &#34;{&#34; | &#34;}&#34; }
shorthand_deny  = { NEWLINE | shorthand_bounds | &#34;,&#34; | &#34;-&#34; }
shorthand_allow = { &#34;\\,&#34; | &#34;\\\\&#34; | &#34;\\{&#34; | &#34;\\}&#34; | &#34;\\-&#34; }
</code></pre><p>Now we will define a key to be used in a regular context.</p><pre tabindex=0><code>key = { ^&#34;enter&#34; | ^&#34;return&#34; | ASCII_ALPHANUMERIC }
key_normal =  { send? ~ on_release? ~ (key | &#34;,&#34; | &#34;-&#34;) }
</code></pre><p>You may ignore the <code>send</code> and <code>on_release</code> attributes for now but that is the
general definition of keys in the grammar.</p><pre tabindex=0><code>key_in_shorthand = {
 !shorthand_deny ~ send? ~ on_release? ~ (shorthand_allow | key)
}
</code></pre><p>In case of keys in a shorthand, we first make sure that it does not match keys denied in the context of
a shorthand (<code>!shorthand_deny</code>). Ignoring the attributes again, we match the allowed escaped versions of
the keys denied earlier (<code>shorthand_allow</code>) or any other regular key that does not need escaping.</p><p>We had also talked about a convenience features that allowed us to specify a range using dashes.
Since they are meant to be used inside shorthands, we reuse the <code>key_in_shorthand</code> expression to define
a key range like so:</p><pre tabindex=0><code>key_range = { key_in_shorthand ~ &#34;-&#34; ~ key_in_shorthand }
</code></pre><p>We use a blanket expression for building the overall shorthand expression called <code>key_or_range</code>. It does
exactly what it says, it is either a bare key or a dashed range in a shorthand context.</p><pre tabindex=0><code>key_or_range = _{ key_range | key_in_shorthand }
</code></pre><p>Note the use of the underscore while defining the grammar. This allows us to reference the expression without
needlessly exposing it to the code side.</p><p>We will now slowly build a shorthand from the expressions defined so far.
Let&rsquo;s think through what makes up a shorthand, starting from the outside.</p><p>A shorthand must begin and end in opening and closing curly braces respectively.</p><pre tabindex=0><code>shorthand = {
    &#34;{&#34;
    ~ // ...
    ~ &#34;}&#34;
}
</code></pre><p>When does a shorthand make sense to use? Well, we generally use them to define two or more bindings succinctly.</p><p>Therefore, we can dedeuce the possible expressions that a shorthand may begin with.
These are as follows:</p><table><thead><tr><th>first</th><th>second</th><th>example</th></tr></thead><tbody><tr><td>key</td><td>key</td><td><code>{a,b}</code></td></tr><tr><td>key</td><td>range</td><td><code>{a,b-c}</code></td></tr><tr><td></td><td>range</td><td><code>{a-c}</code></td></tr></tbody></table><p>We can model these three cases in the grammar like so:</p><pre tabindex=0><code>(key_in_shorthand ~ &#34;,&#34; ~ key_in_shorthand)
| (key_in_shorthand ~ &#34;,&#34; ~ key_range)
| key_range
</code></pre><p>These starting expressions can be followed by one or more keys or ranges. This is where the blanket expression <code>key_or_range</code> we defined
earlier make our lives easy. We can also make the above expression a little concise by abusing the blanket expression.</p><p>You see, for the first two possibilities, we are essentially saying that it needs to be a <code>key_in_shorthand</code>, a comma
and <em>either another key or a range</em>. So those two can boil down to use a <code>key_or_range</code> after the comma.</p><pre tabindex=0><code>(key_in_shorthand ~ &#34;,&#34; ~ key_or_range)
| key_range
</code></pre><p>Putting it all together, we get the following expression for a shorthand.</p><pre tabindex=0><code>shorthand = {
    &#34;{&#34;
    ~ ((key_in_shorthand ~ &#34;,&#34; ~ key_or_range) | key_range)
    ~ (&#34;,&#34; ~ key_or_range)*
    ~ &#34;}&#34;
}
</code></pre><p>Here <code>("," ~ key_or_range)*</code> represents the zero or more keys or ranges that the user may supply after the starting sequence.</p><p>That&rsquo;s all for today, I hope my explanation was not too convoluted. In the next post, I will talk about the <code>send</code> and the <code>on_release</code>
attributes that describe the timing of a keypress and how we handle the grammar for them.</p><p>Talk to you then!</p></section><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav data-post><a href=https://lavafroth.is-a.dev/post/timing-is-key/><span>←</span><span>Timing is Key: A Tale of Keystrokes and Timings</span></a>
<a href=https://lavafroth.is-a.dev/post/2-afternoons-2-languages-2-tuis/><span>2 Afternoons, 2 Languages, 2 TUIs</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2026 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>