<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Edge cases? You Shall Not Pass! - lavafroth</title><meta name=description content='This post is a part of a series that explains the architecture of the config parser
I am building for swhkd as a part of Google Summer of Code. I highly recommend reading
through the previous posts as I&rsquo;ll be referring to them from time to time.
In the last post I talked about key attributes that can be used as prefix to denote
the timing of an event, on key press (send / ~) or release (on_release / @). One nuanced
case we did not cover was the use of these attributes inside shorthands.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><noscript><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/noscript.min.css></noscript><link rel=prefetch as=font href=https://lavafroth.is-a.dev/LeagueGothic.ttf><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body class=not-ready data-menu=true><header class=header><div class=coalesce><h1><a class=site-name href=https://lavafroth.is-a.dev/>lavafroth</a></h1><svg class="btn-dark" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 60 60" preserveAspectRatio="xMinYMin meet"><path class="circle" d="M30 16c7.73.0 14 6.27 14 14 0 3.81-1.53 7.27-4 9.8-2.54 2.59-6.08 4.2-10 4.2-7.73.0-14-6.27-14-14 0-7.73 6.27-14 14-14z"/><g class="rays" data-svg-origin="30 30"><line class="line" x1="30" y1="11" x2="30" y2="7"/><line class="line" x1="43.44" y1="16.57" x2="46.26" y2="13.74"/><line class="line" x1="49" y1="30" x2="53" y2="30"/><line class="line" x1="43.43" y1="43.44" x2="46.26" y2="46.26"/><line class="line" x1="30" y1="49" x2="30" y2="53"/><line class="line" x1="16.56" y1="43.43" x2="13.74" y2="46.26"/><line class="line" x1="11" y1="30" x2="7" y2="30"/><line class="line" x1="16.57" y1="16.56" x2="13.74" y2="13.74"/></g></svg></div><nav class=social><a class=github style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a></nav><script>const bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>(bodyClx.toggle("dark",e),localStorage.setItem("dark",e));setDark(darkVal?darkVal==="true":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",({matches:e})=>setDark(e))</script></header><main class=main><article class=post-single><header class=post-title><p><time>Jun 3, 2024 | 4 minutes read</time></p><h1 data-pagefind-meta=title>Edge cases? You Shall Not Pass!</h1></header><section class=post-content data-pagefind-body><p>This post is a part of a series that explains the architecture of the config parser
I am building for swhkd as a part of Google Summer of Code. I highly recommend reading
through the previous posts as I&rsquo;ll be referring to them from time to time.</p><p>In the last post I talked about key attributes that can be used as prefix to denote
the timing of an event, on key press (<code>send</code> / <code>~</code>) or release (<code>on_release</code> / <code>@</code>). One nuanced
case we did not cover was the use of these attributes inside shorthands.</p><p>If a user is supplying a config file with a shorthand along with any of these attributes, should the
attribute remain outside the shorthand or be prefixed for each variant inside the shorthand? Consider
the following two cases: one where the attribute is outside the shorthand context</p><pre tabindex=0><code>super + @{a, b, c-f}
  ...
</code></pre><p>and another with the attribute inside the shorthand context.</p><pre tabindex=0><code>super + {@a, b, c-f}
  ...
</code></pre><p>We can notice that while the first case is easier to implement, the second case gives us more granularity where different keys can have different attributes.
However, this introduces another hidden complexity that we have to tackle, what if range bounds have different attributes? Take the following example:</p><pre tabindex=0><code>super + {~a-@f}
  ...
</code></pre><p>What does it mean to have a range with the keypress send event for <code>a</code> to the keypress release event for <code>f</code>? Should the elided inbetweens have a <code>send</code> or an <code>on_release</code>
modifier? The original parser also conveniently sidesteps this entirely by not entertaining attributes in shorthands (bruh).
Since we can never be sure of what the user is trying to convey in such cases, our best attempt at handling this would be to simply throw an error to the user.</p><p>Thus, our new parser adds the ability to have attributes inside a shorthand as long as range bounds have the same attribute, all the while maintaining backward compatibility
with the older parser!</p><p>Now let&rsquo;s come to the second issue that I discovered during some manual testing this week. I supplied the following config to my parser</p><pre tabindex=0><code>super + \+
   mpv ~/Music
</code></pre><p>and to my horror, the parser parsed the following:</p><pre tabindex=0><code>Binding [Modifier(&#34;super&#34;), Key { key: &#34;&#34;, attribute: KeyAttribute(0x0) }] → mpv ~/Music
</code></pre><p>Did you catch it? Take a closer look at the key field in the definition, the escaped key is parsed as empty for some reason.
It turns out that the escaped keys that were part of the <code>shorthand_allow</code> expression were not consistently exposed as a rule
for the code side. Thus, I forgot to parse them back as keys.</p><p>To fix this, we restructure the expressions for keys in normal and shorthand contexts.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>keys_always_escaped <span style=color:#f92672>=</span> _{ <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>~&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>@&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>+&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\\\</span><span style=color:#e6db74>&#34;</span> }
</span></span><span style=display:flex><span>key_base <span style=color:#f92672>=</span> { keys_always_escaped <span style=color:#f92672>|</span> <span style=color:#f92672>^</span><span style=color:#e6db74>&#34;enter&#34;</span> <span style=color:#f92672>|</span> <span style=color:#f92672>^</span><span style=color:#e6db74>&#34;return&#34;</span> <span style=color:#f92672>|</span> ASCII_ALPHANUMERIC }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>key_attributes <span style=color:#f92672>=</span> _{ send<span style=color:#960050;background-color:#1e0010>?</span> <span style=color:#f92672>~</span> on_release<span style=color:#960050;background-color:#1e0010>?</span> }
</span></span><span style=display:flex><span>key_normal <span style=color:#f92672>=</span>  { key_attributes <span style=color:#f92672>~</span> (key_base <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;,&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;-&#34;</span>) }
</span></span><span style=display:flex><span>key_in_shorthand <span style=color:#f92672>=</span> { <span style=color:#960050;background-color:#1e0010>!</span>shorthand_deny <span style=color:#f92672>~</span> key_attributes <span style=color:#f92672>~</span> (shorthand_allow <span style=color:#f92672>|</span> key_base) }
</span></span></code></pre></div><p>This makes our life a tad bit easier because for every match of a <code>key_normal</code> or a <code>key_in_shorthand</code>,
we can easily extract the variants of <code>key_attributes</code> if any as well as the key itself from the <code>key_base</code> or <code>shorthand_allow</code>.</p><p>Finally, let get to unescaping the keys themselves. Initially, the idea was to use <code>unescape</code> function from the snailquote crate
since it allows unescaping any escaped sequence, be it ASCII or unicode. However, we quickly find that we also have to check
whether the keys we just unescaped are supposed to escaped in the first place.</p><p>It makes more sense here to write a small function ourselves to both check for values we know must be escaped as well as escaping
them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>unescape</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> chars: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> s.chars().collect();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> [<span style=color:#e6db74>&#39;\\&#39;</span>, ch] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>chars[<span style=color:#f92672>..</span>] <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Pest guarantees this for us. Still keeping a bit of sanity check.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>assert!</span>(<span style=color:#a6e22e>matches!</span>(ch, <span style=color:#e6db74>&#39;{&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;}&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;,&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;\\&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;+&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;~&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;@&#39;</span>));
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this new function, our parser correctly unescapes the keys like so:</p><pre tabindex=0><code>Binding [Modifier(&#34;super&#34;), Key { key: &#34;+&#34;, attribute: KeyAttribute(0x0) }] → mpv ~/Music
</code></pre><p>Okay, that&rsquo;s all for now. I know I was supposed to talk about modifiers. I will do that in
the next post because fixing this bug and keeping logs of why I did it felt more important.</p><p>See you soon!</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/><span>←</span><span>Modeling More Realistic Keybinds With Modifiers</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/timing-is-key/><span>Timing is Key: A Tale of Keystrokes and Timings</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a> | <a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a> | <a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a> | <a href=https://lavafroth.is-a.dev/privacy>Privacy</a> | <a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>