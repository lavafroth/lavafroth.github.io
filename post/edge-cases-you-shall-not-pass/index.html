<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Edge cases? You Shall Not Pass! - lavafroth</title><meta name=description content='This post is a part of a series that explains the architecture of the config parser
I am building for swhkd as a part of Google Summer of Code. I highly recommend reading
through the previous posts as I&rsquo;ll be referring to them from time to time.
In the last post I talked about key attributes that can be used as prefix to denote
the timing of an event, on key press (send / ~) or release (on_release / @). One nuanced
case we did not cover was the use of these attributes inside shorthands.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/rss.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body><header><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2400"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a><nav><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><a href=../../index.xml aria-label=rss style=--url:url(./rss.svg)></a><nav></header><main><article class=post-single data-pagefind-body><hgroup><p data-pagefind-ignore><time>Jun 3, 2024 | 4 minutes read</time></p><h1 data-pagefind-meta=title>Edge cases? You Shall Not Pass!</h1></hgroup><section class=post-content><p>This post is a part of a series that explains the architecture of the config parser
I am building for swhkd as a part of Google Summer of Code. I highly recommend reading
through the previous posts as I&rsquo;ll be referring to them from time to time.</p><p>In the last post I talked about key attributes that can be used as prefix to denote
the timing of an event, on key press (<code>send</code> / <code>~</code>) or release (<code>on_release</code> / <code>@</code>). One nuanced
case we did not cover was the use of these attributes inside shorthands.</p><p>If a user is supplying a config file with a shorthand along with any of these attributes, should the
attribute remain outside the shorthand or be prefixed for each variant inside the shorthand? Consider
the following two cases: one where the attribute is outside the shorthand context</p><pre tabindex=0><code>super + @{a, b, c-f}
  ...
</code></pre><p>and another with the attribute inside the shorthand context.</p><pre tabindex=0><code>super + {@a, b, c-f}
  ...
</code></pre><p>We can notice that while the first case is easier to implement, the second case gives us more granularity where different keys can have different attributes.
However, this introduces another hidden complexity that we have to tackle, what if range bounds have different attributes? Take the following example:</p><pre tabindex=0><code>super + {~a-@f}
  ...
</code></pre><p>What does it mean to have a range with the keypress send event for <code>a</code> to the keypress release event for <code>f</code>? Should the elided inbetweens have a <code>send</code> or an <code>on_release</code>
modifier? The original parser also conveniently sidesteps this entirely by not entertaining attributes in shorthands (bruh).
Since we can never be sure of what the user is trying to convey in such cases, our best attempt at handling this would be to simply throw an error to the user.</p><p>Thus, our new parser adds the ability to have attributes inside a shorthand as long as range bounds have the same attribute, all the while maintaining backward compatibility
with the older parser!</p><p>Now let&rsquo;s come to the second issue that I discovered during some manual testing this week. I supplied the following config to my parser</p><pre tabindex=0><code>super + \+
   mpv ~/Music
</code></pre><p>and to my horror, the parser parsed the following:</p><pre tabindex=0><code>Binding [Modifier(&#34;super&#34;), Key { key: &#34;&#34;, attribute: KeyAttribute(0x0) }] → mpv ~/Music
</code></pre><p>Did you catch it? Take a closer look at the key field in the definition, the escaped key is parsed as empty for some reason.
It turns out that the escaped keys that were part of the <code>shorthand_allow</code> expression were not consistently exposed as a rule
for the code side. Thus, I forgot to parse them back as keys.</p><p>To fix this, we restructure the expressions for keys in normal and shorthand contexts.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>keys_always_escaped <span style=color:#f92672>=</span> _{ <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>~&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>@&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>+&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\\\</span><span style=color:#e6db74>&#34;</span> }
</span></span><span style=display:flex><span>key_base <span style=color:#f92672>=</span> { keys_always_escaped <span style=color:#f92672>|</span> <span style=color:#f92672>^</span><span style=color:#e6db74>&#34;enter&#34;</span> <span style=color:#f92672>|</span> <span style=color:#f92672>^</span><span style=color:#e6db74>&#34;return&#34;</span> <span style=color:#f92672>|</span> ASCII_ALPHANUMERIC }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>key_attributes <span style=color:#f92672>=</span> _{ send<span style=color:#960050;background-color:#1e0010>?</span> <span style=color:#f92672>~</span> on_release<span style=color:#960050;background-color:#1e0010>?</span> }
</span></span><span style=display:flex><span>key_normal <span style=color:#f92672>=</span>  { key_attributes <span style=color:#f92672>~</span> (key_base <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;,&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;-&#34;</span>) }
</span></span><span style=display:flex><span>key_in_shorthand <span style=color:#f92672>=</span> { <span style=color:#960050;background-color:#1e0010>!</span>shorthand_deny <span style=color:#f92672>~</span> key_attributes <span style=color:#f92672>~</span> (shorthand_allow <span style=color:#f92672>|</span> key_base) }
</span></span></code></pre></div><p>This makes our life a tad bit easier because for every match of a <code>key_normal</code> or a <code>key_in_shorthand</code>,
we can easily extract the variants of <code>key_attributes</code> if any as well as the key itself from the <code>key_base</code> or <code>shorthand_allow</code>.</p><p>Finally, let get to unescaping the keys themselves. Initially, the idea was to use <code>unescape</code> function from the snailquote crate
since it allows unescaping any escaped sequence, be it ASCII or unicode. However, we quickly find that we also have to check
whether the keys we just unescaped are supposed to escaped in the first place.</p><p>It makes more sense here to write a small function ourselves to both check for values we know must be escaped as well as escaping
them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>unescape</span>(s: <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span>) -&gt; <span style=color:#66d9ef>&amp;</span><span style=color:#66d9ef>str</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> chars: Vec<span style=color:#f92672>&lt;</span>_<span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> s.chars().collect();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> [<span style=color:#e6db74>&#39;\\&#39;</span>, ch] <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>chars[<span style=color:#f92672>..</span>] <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> s;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Pest guarantees this for us. Still keeping a bit of sanity check.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>assert!</span>(<span style=color:#a6e22e>matches!</span>(ch, <span style=color:#e6db74>&#39;{&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;}&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;,&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;\\&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;-&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;+&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;~&#39;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#39;@&#39;</span>));
</span></span><span style=display:flex><span>    <span style=color:#f92672>&amp;</span>s[<span style=color:#ae81ff>1</span><span style=color:#f92672>..</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With this new function, our parser correctly unescapes the keys like so:</p><pre tabindex=0><code>Binding [Modifier(&#34;super&#34;), Key { key: &#34;+&#34;, attribute: KeyAttribute(0x0) }] → mpv ~/Music
</code></pre><p>Okay, that&rsquo;s all for now. I know I was supposed to talk about modifiers. I will do that in
the next post because fixing this bug and keeping logs of why I did it felt more important.</p><p>See you soon!</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/modeling-more-realistic-keybinds-with-modifiers/><span>←</span><span>Modeling More Realistic Keybinds With Modifiers</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/timing-is-key/><span>Timing is Key: A Tale of Keystrokes and Timings</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>