<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Modeling More Realistic Keybinds With Modifiers - lavafroth</title><meta name=description content='Real world keybindings for shortcuts often involve more than just a simple keypress, especially outside the context of
a single application. The general distinction for these two types involves modifier keys. When I talk about a shortcut
bound to super v, chances are you automatically think of global bindings at the operating system or desktop environment
level. Today we&rsquo;ll go through the process of writing the grammar for these bindings for swhkd.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2400"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a></h1><div class=push></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a></header><main class=main><article class=post-single data-pagefind-body><header class=post-title><p data-pagefind-ignore><time>Jun 5, 2024 | 4 minutes read</time></p><h1 data-pagefind-meta=title>Modeling More Realistic Keybinds With Modifiers</h1></header><section class=post-content><p>Real world keybindings for shortcuts often involve more than just a simple keypress, especially outside the context of
a single application. The general distinction for these two types involves modifier keys. When I talk about a shortcut
bound to <code>super</code> <code>v</code>, chances are you automatically think of global bindings at the operating system or desktop environment
level. Today we&rsquo;ll go through the process of writing the grammar for these bindings for swhkd.</p><p>Welcome to the fifth instalment in the series where we build a config parser using Rust and <em>pest.rs</em>. I highly recommend
you going through the previous posts because I&rsquo;ll refer to them from time to time.</p><p>Let&rsquo;s begin by defining possible modifiers that can be used by our parser. The EBNF grammar expression looks like the following:</p><pre tabindex=0><code>modifier = {
    ^&#34;alt&#34;
    | ^&#34;altgr&#34;
    | ^&#34;control&#34;
    | ^&#34;ctrl&#34;
    | ^&#34;mod1&#34;
    | ^&#34;mod4&#34;
    | ^&#34;mod5&#34;
    | ^&#34;shift&#34;
    | ^&#34;super&#34;
    | ^&#34;any&#34;
}
</code></pre><p>We are using the or operator (<code>|</code>) to match any of the strings. Notice the use of the caret (<code>^</code>) before the start of every string.
We do this to ensure that the matched modifiers are case insensitive. There&rsquo;s not a lot for us to do when it comes to a regular
binding like the following:</p><pre tabindex=0><code>super + v
  pkexec rm -rf / --no-preserve-root
</code></pre><p>However, there are a few quirks with how modifiers behave inside shorthands. Recall from the first general overview post that
modifiers can also be placed inside shorthands, separating each variant with a comma.</p><pre tabindex=0><code>super + {alt, ctrl} + a
  ls {foo, bar}
</code></pre><p>During early development, I had created a copy of the expression for regular keys to match modifiers. Turns out, the strict
set of possible modifiers actually eliminates quite some pain that we went through developing expressions for regular keys.
The most obvious simplification is not needing to match the characters denied in a shorthand.</p><p>Since pest and other EBNF parsers are greedy parsers, we had to explicitly make sure that the expression for keys starts out
by <em>not</em> matching any of the denylist characters.</p><pre tabindex=0><code>key_in_shorthand = { !shorthand_deny ~ key_attributes ~ (shorthand_allow | key_base) }
</code></pre><p>Notice we had to negate (<code>!</code>) <code>shorthand_deny</code> before we could even start matching key attributes and such.
In case of modifier, our match pool gets narrowed to the few strings we defined earlier. Thus, we don&rsquo;t even have to think about
having a denylist, those characters would not be considered as modifers to begin with.</p><p>With this simplification in mind, we can now create a shorthand expression for modifiers.</p><pre tabindex=0><code>modifier_shorthand = { &#34;{&#34; ~ (modifier ~ &#34;,&#34;)+ ~ modifier ~ &#34;}&#34; }
</code></pre><p>We defined the expression such that it starts and ends with curly braces, the boundary delimiters of shorthands and two or more comma
separate modifiers. So far so good.</p><p>Now let&rsquo;s come to omissions. Omissions allow us to, well, omit modifiers inside shorthands. Using omissions requires us to replace one
of the shorthand variants with an underscore. Each of the remaining variants that are not omitted must be suffixed with a concatenator <code>+</code>
while the contcatenator outside the shorthand gets remove.</p><p>You can imagine the outside plus shifting inside the shorthand, getting distributed across all the non omitted variants.</p><pre tabindex=0><code>super + {alt +, _, shift +} a
  ls {foo, bar, baz}
</code></pre><p>Since this is the only time we don&rsquo;t have a trailing concatenator, we model this expression separately. We start out by defining an omission.</p><pre tabindex=0><code>omission                =  { &#34;_&#34; }
modifier_omit           = _{ omission | (modifier ~ concat) }
modifier_omit_shorthand =  { &#34;{&#34; ~ modifier_omit ~ (&#34;,&#34; ~ modifier_omit)+ ~ &#34;}&#34; }
</code></pre><p>Each variant (<code>modifier_omit</code>) inside such a shorthand can either be an omission or a modifier <em>and</em> a concatentator.
We can then package multiple of these up into a single expression like we did previously with the regular modifier shorthand.</p><p>For all the other cases where the concatenator is outside the shorthand context, we create a blanket expression.</p><pre tabindex=0><code>modifier_or_shorthand = _{ (modifier | modifier_shorthand) ~ concat }
</code></pre><p>Let&rsquo;s combine the expressions we have built so far to build one of the workhorse primitives in our parser: a trigger for a binding.</p><pre tabindex=0><code>trigger = _{ (modifier_or_shorthand | modifier_omit_shorthand)* ~ (key_normal | shorthand) }
</code></pre><p>Notice how there is no explicit concatenator between the expression for one or more modifiers (or their shorthands) and the trailing
key (or their shorthands). This is because we have already encoded where the plus sign should be in the individual expression for
<code>modifier_or_shorthand</code> and <code>modifier_omit_shorthand</code>.</p><p>The expression for a trigger is meaningless outside the context of a binding. Thus, the expression is silenced with the underscore at the start.
If you are wondering why this is not a complete binding, remember we still need to make room for commands and comments.</p><p>In fact, that&rsquo;s going to be the topic for the next post, so stay tuned and I&rsquo;ll see you around!</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/i-solemnly-swear-to-never-buy-a-gaming-laptop-again/><span>←</span><span>I Solemnly Swear to Never Buy a Gaming Laptop Again</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/><span>Edge cases? You Shall Not Pass!</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>