<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Preventing Infinite Recursions From Eating Your Lunch - lavafroth</title><meta name=description content='Hello and welcome to the eighth instalment in the series where we build a
parser for a domain specific language in Rust. I&rsquo;d highly recommend
going through the previous articles to make sense of what we’ll talk about today.
After a bit of back and forth with my mentor, we landed on moving the logic that imports
other config files into the parser crate itself. Config files can reference other modules
using import statements of the following form:'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><noscript><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/noscript.min.css></noscript><link rel=prefetch as=font href=https://lavafroth.is-a.dev/LeagueGothic.ttf><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body class=not-ready data-menu=true><header class=header><div class=coalesce><h1><a class=site-name href=https://lavafroth.is-a.dev/>lavafroth</a></h1><svg class="btn-dark" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 60 60" preserveAspectRatio="xMinYMin meet"><path class="circle" d="M30 16c7.73.0 14 6.27 14 14 0 3.81-1.53 7.27-4 9.8-2.54 2.59-6.08 4.2-10 4.2-7.73.0-14-6.27-14-14 0-7.73 6.27-14 14-14z"/><g class="rays" data-svg-origin="30 30"><line class="line" x1="30" y1="11" x2="30" y2="7"/><line class="line" x1="43.44" y1="16.57" x2="46.26" y2="13.74"/><line class="line" x1="49" y1="30" x2="53" y2="30"/><line class="line" x1="43.43" y1="43.44" x2="46.26" y2="46.26"/><line class="line" x1="30" y1="49" x2="30" y2="53"/><line class="line" x1="16.56" y1="43.43" x2="13.74" y2="46.26"/><line class="line" x1="11" y1="30" x2="7" y2="30"/><line class="line" x1="16.57" y1="16.56" x2="13.74" y2="13.74"/></g></svg></div><nav class=social><a class=github style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a></nav><script>const bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>(bodyClx.toggle("dark",e),localStorage.setItem("dark",e));setDark(darkVal?darkVal==="true":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",({matches:e})=>setDark(e))</script></header><main class=main><article class=post-single><header class=post-title><p><time>Jul 4, 2024 | 4 minutes read</time></p><h1 data-pagefind-meta=title>Preventing Infinite Recursions From Eating Your Lunch</h1></header><section class=post-content data-pagefind-body><p>Hello and welcome to the eighth instalment in the series where we build a
parser for a domain specific language in Rust. I&rsquo;d highly recommend
going through the previous articles to make sense of what we’ll talk about today.</p><p>After a bit of back and forth with my mentor, we landed on moving the logic that imports
other config files into the parser crate itself. Config files can reference other modules
using import statements of the following form:</p><pre tabindex=0><code>include some_other_module.swhkd
</code></pre><p>The grammar side is fairly simple to implement, we match the token &ldquo;include&rdquo; followed by
a path to some other file.</p><pre tabindex=0><code>import_file = { (!NEWLINE ~ ANY)+ }
import      = { &#34;include&#34; ~ import_file }
</code></pre><p>We&rsquo;ll add this to the core set of variants so that we can actually match the expression.</p><pre tabindex=0><code>content = _{ comment | mode | unbind | binding | import | NEWLINE }
</code></pre><p>Now we could very well blindly recurse through modules imported one after another but
that comes with the subtle pitfall of an infinite recursion. Allow me to elaborate:</p><p>Assume you have a module called <code>module_a</code> that is the top-level or the root config file.
Let&rsquo;s say it imports another module, <code>module_b</code>. If <code>module_b</code> now imports <code>module_a</code>,
our code enters an infinite recursion state, continuously evaluating these two modules forever.</p><p>Thus, the key takeaway is to implement book-keeping for the import paths so that they
form a directional acyclic graph. This requires us to write some additional code for
our parser.</p><p>First, let&rsquo;s create a field in our parser struct that stores tha names of all the imports it
has seen.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>SwhkdParser</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> bindings: Vec<span style=color:#f92672>&lt;</span>Binding<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> unbinds: Vec<span style=color:#f92672>&lt;</span>Definition<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> imports: <span style=color:#a6e22e>BTreeSet</span><span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> modes: Vec<span style=color:#f92672>&lt;</span>Mode<span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice that the import field is a <code>BTreeSet</code> or a binary tree set. As you might know, adding
duplicate elements to a set discards them, keeping only the unique elements behind. Although we could have
used a <code>HashSet</code> here, a binary tree set is faster since it does not require a dedicated
hashing function. Considering that the average setup
would not wield even a thousand submodules, it&rsquo;s sufficient to store the imports in a set.</p><p>We&rsquo;ll create slightly separate implementations to differentiate between the root module
and any submodules it imports. For now, let&rsquo;s tackle the implementation for the submodules.</p><p>We create a method for the parser result called <code>as_import</code> for loading any of these aforementioned submodules.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>as_import</span>(input: <span style=color:#a6e22e>ParserInput</span>, seen: <span style=color:#66d9ef>&amp;</span><span style=color:#a6e22e>mut</span> BTreeSet<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, ParseError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The <code>seen</code> argument is how the caller tells the callee about what import paths it has already seen.</p><p>While processing import expressions, we keep adding the imports we have seen so far to a local <code>BTreeSet</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> imports <span style=color:#f92672>=</span> BTreeSet::new();
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> decl <span style=color:#66d9ef>in</span> contents.into_inner() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> decl.as_rule() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// other rules like bindings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Rule::import <span style=color:#f92672>=&gt;</span> imports.extend(import_parser(decl)),
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Once all the tokens in the current config have been parsed, we can move on to adding the imports to
the set of <code>seen</code> imports.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(import) <span style=color:#f92672>=</span> imports.pop_first() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>!</span>seen.insert(import.clone()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> child <span style=color:#f92672>=</span> Self::as_import(ParserInput::Path(Path::new(<span style=color:#f92672>&amp;</span>import)), seen)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    imports.extend(child.imports);
</span></span><span style=display:flex><span>    bindings.extend(child.bindings);
</span></span><span style=display:flex><span>    unbinds.extend(child.unbinds);
</span></span><span style=display:flex><span>    modes.extend(child.modes);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Although we recurse here, the base case when the set of <code>seen</code> elements already contains an import
saves us from entering an infinite loop.</p><p>Once that&rsquo;s done, we can return the newly parsed result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>Ok(SwhkdParser {
</span></span><span style=display:flex><span>    bindings,
</span></span><span style=display:flex><span>    unbinds,
</span></span><span style=display:flex><span>    imports,
</span></span><span style=display:flex><span>    modes,
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>Coming back to the root config, this is where we create the topmost set of <code>seen</code> imports that can
be passed on to any <code>Self::as_import</code> calls.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>from</span>(input: <span style=color:#a6e22e>ParserInput</span>) -&gt; Result<span style=color:#f92672>&lt;</span>Self, ParseError<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> root_imports <span style=color:#f92672>=</span> BTreeSet::new();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> root <span style=color:#f92672>=</span> Self::as_import(input, <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> root_imports)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    root.imports <span style=color:#f92672>=</span> root_imports;
</span></span><span style=display:flex><span>    Ok(root)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We start off with an empty set and delegate the loading of the config to the <code>as_import</code> function,
sending it a mutable reference to this (kind of) global source of truth, at least throughout the
call stack of import related functions.</p><p>Lastly, for the sake of backwards compatibility, we assign the imports we have seen so far to the
root parser result. This was the behavior present in the original parser. Note that the import
fields in the submodules will all be empty since we popped them one by one in this loop:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(import) <span style=color:#f92672>=</span> imports.pop_first() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Okay, that&rsquo;s all for now. See you soon!</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/humans-suck-at-command-sanitization/><span>←</span><span>Humans Suck at Command Sanitization</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/test-driven-development-the-pinnacle-of-engineering/><span>Test Driven Development - The Pinnacle of Engineering</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a> | <a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a> | <a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a> | <a href=https://lavafroth.is-a.dev/privacy>Privacy</a> | <a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>