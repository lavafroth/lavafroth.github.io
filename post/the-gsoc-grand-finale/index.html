<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Wrapping up GSoC 2024 - lavafroth</title><meta name=description content='Overview
Hello and welcome to the final GSoC post for 2024! My task was to formalize the SWHKD parser using context-free EBNF notation. This post is to serve as a birdseye view of what
I have developed over this summer.
Report
Architecting the parser
I started out with the scaffolding of the parser in an extended Backus-Naur form garmmar template
in a separate repository called SWEET using a Rust framework
called pest.rs. Quite a lot of time was
spent in modelling the architecture of the syntax tree for our domain specific language.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2400"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a></h1><div class=push></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a></header><main class=main><article class=post-single><header class=post-title><p><time>Aug 24, 2024 | 6 minutes read</time></p><h1 data-pagefind-meta=title>Wrapping up GSoC 2024</h1></header><section class=post-content data-pagefind-body><h1 id=overview>Overview</h1><p>Hello and welcome to the final GSoC post for 2024! My task was to formalize the SWHKD parser using context-free EBNF notation. This post is to serve as a birdseye view of what
I have developed over this summer.</p><h1 id=report>Report</h1><h2 id=architecting-the-parser>Architecting the parser</h2><p>I started out with the scaffolding of the parser in an extended Backus-Naur form garmmar template
in a separate repository called <a href=https://github.com/waycrate/sweet>SWEET</a> using a Rust framework
called <a href=https://pest.rs>pest.rs</a>. Quite a lot of time was
spent in modelling the architecture of the syntax tree for our domain specific language.</p><p>Here&rsquo;s a simplified syntax tree of the grammar parser.</p><p><img src=../../sweet-architecture.svg alt="A flowchart showing the working of the abstract syntax tree"></p><p>One of the most helpful design choices was to have an acyclic dependency graph which enabled composing
expressions into larger blocks.</p><h2 id=isolating-shorthands-into-separate-expressions>Isolating shorthands into separate expressions</h2><p>Shorthands expressions inside curly braces which were previously parsed dynamically have now been moved
to work statically from the grammar side itself. This has two advantages:</p><ul><li>The matching of both comma separated <em>&ldquo;slices&rdquo;</em> and dash separated <em>&ldquo;ranges&rdquo;</em> can be proven from the grammar template itself.</li><li>Due to the greedy token matching of EBNF, the negative lookaheads guarantee a finite number of tokens to match a slice or range.</li><li>Extracting the components inside these blocks are performed in a single pass.</li></ul><p>The latter is a theme that will continue throughout the rest of this report.</p><h2 id=adopting-static-checks>Adopting static checks</h2><p>Many of the earlier hand-rolled checks have now been moved to the grammar side and are now performed statically.
We are borrowing a concept from the Rust programming language itself which promotes making invalid states unrepresentable.</p><p>One such example is validating characters inside ranges. The specification requires these characters
to be within the ASCII range. We define this constraint inside the grammar template itself.</p><p>This way, if some invalid input is supplied, it never hits the business logic and the program errors out early.</p><h2 id=separating-channels-of-commands-and-mode-instructions>Separating channels of commands and mode instructions</h2><p>SWHKD supports entering or escaping a mode by placing special instructions after the double ampersands between two commands.
Previously,
these instructions were extracted from the commands dynamically right before they were being run
line by line. This led to edge cases where the command being run is not what the user intended.</p><p>To sanitize this, we perform static extraction of these modes in the context of an entire block of
commands. We create a separate structure linked to a command structure that can hold arbitrarily many of these mode instructions
and the instructions are run only after all the command chunks have been executed.</p><h2 id=unified-shorthand-syntax>Unified shorthand syntax</h2><p>This is one of the breaking changes introduced in the new parser.</p><p>Previously, when modifiers were
used inside shorthands, one could place the concatenator (plus sign) either outside or inside the
braces. This allowed somewhat off looking combinations like these:</p><pre tabindex=0><code>{super, control + } + a
  notify-send {&#39;hello&#39;, &#39;goodbye&#39;}
</code></pre><p>This was allowed because the older parser simply ignored the concatenator, using the closing curly
brace as a confirmation for the end of a shorthand.</p><p>The new parser disallows this behavior. When using multiple modifiers, one must simply place an concatenator after the shorthand ends.
The above example then turns into the following:</p><pre tabindex=0><code>{super, control} + a
  notify-send {&#39;hello&#39;, &#39;goodbye&#39;}
</code></pre><p>Now there&rsquo;s at most one way to do shorthands correct:</p><ul><li>A shorthand must contain at least two variants. It makes no sense to use shorthands otherwise.</li><li>Any literal like a comma or a curly brace inside a shorthand must be escaped</li><li>Literals do not need to be escaped outside shorthand contexts.</li><li>Shorthands with omissions (underscore elements) must always have a concatenator appended to each non-empty element. For example, unlike <code>{control, super} + a</code>, in <code>{_, super + } a</code> adding a plus to <code>super</code> inside the shorthand is the only valid syntax.</li></ul><p>A good comparison would be bash or Rust macro expansions. Here&rsquo;s an animation as to how we perform
a &ldquo;compilation&rdquo;.</p><p><img src=../../swhkd-macro-compilation.gif alt></p><p>The new parser simply keeps track of shorthand values including ranges and slices as long as it is
ingesting newer content. These shorthands are lazily evaluated in the end when all files, including
imports have been ingested.</p><h2 id=more-human-friendly-errors>More human friendly errors</h2><p>One of the most difficult ways to get a working config for a tool like SWHKD is the lack of helpful
errors. The new parser addresses most of these issues. With the pest crate, we have been able to
provide rich contextual errors. Here&rsquo;s an example:</p><pre tabindex=0><code>Error: unable to parse config file

Caused by:
      --&gt; hotkeys.swhkd:20:11
       |
    20 | super + k + control
       |           ^---
       |
       = expected command
</code></pre><p>Instead of just printing what the error was, we try to help the user by letting them know about what
the parser expected, where in the source file does the error exists and any suggestion available to
fix the error.</p><p>This not only applies to the grammar errors but to all of the errors in the business logic. Here&rsquo;s an
example of when the number of shorthand variants in the trigger don&rsquo;t match the number of command variants.</p><pre tabindex=0><code>Error: unable to parse config file

Caused by:
      --&gt; 35:1
       |
    35 | super + {alt + , _, shift + } a
    36 |  notify-send &#39;hello&#39;‚êä
       | ^------------------^
       |
       = the number of possible binding variants 3 does not equal the number of possible command variants 1.
</code></pre><p>Our custom error
structures wrap around pest&rsquo;s error types to provide such additional context as and when needed.</p><h2 id=precautions>Precautions</h2><p>Before parsing any config files supplied as input, we perform the following sanity checks:</p><ul><li>Ensure that the files are within the predefined file-size capacity. This capacity can be configured
during compilation by modifying the <code>build.rs</code> file.</li><li>Ensure the file being supplied is a regular file. This is a cautionary measure against an older <a href=https://github.com/advisories/GHSA-x446-3xhq-5xfp>CVE-2022-27814</a>.</li></ul><h1 id=relevant-links>Relevant links</h1><ul><li>Source tree for the parser: <a href=https://github.com/waycrate/sweet>waycrate/sweet</a></li><li>PR to integrate <code>sweet</code> into <code>swhkd</code>: <a href=https://github.com/waycrate/swhkd/pull/265>#265</a></li></ul><h1 id=conclusion>Conclusion</h1><p>Debugging a context free grammar syntax like EBNF was certainly challenging although this issue was solved
relatively easily thanks to the excellent editor provided at the <a href=https://pest.rs>pest.rs</a> website. The parser
has reached complete feature parity, being slightly stricter in some cases as I
had planned with my mentor, Aakash Sen Sharma. Huge thanks to him for the helping me out with getting familiar
with the codebase quickly. The rest of the waycrate community has also been incredibly warm and welcoming.</p><p>I plan to add a heuristics model to SWHKD for detecting input devices better and more generally
to continue improving SWHKD. Feel free to check out related posts <a href=https://lavafroth.is-a.dev/tags/google-summer-of-code>here</a> that go deeper into the process
of building this parser. This has been my GSoC 2024, thank you so much for reading this!</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/nixos-secureboot-shenanigans/><span>‚Üê</span><span>NixOS Secureboot Shenanigans</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/cuda-on-nixos-without-sacrificing-ones-sanity/><span>Painlessly setting up ML tooling on NixOS</span><span>‚Üí</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>