<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Volcano - lavafroth</title><meta name=description content='This reversing challenge is very mathematical, focusing mainly on modulo congruences.
Like all challenges, there is some scary looking obfuscation for the fun which I&rsquo;ll try my best to
explain. The challenge description says that it was inspired by recent &ldquo;traumatic&rdquo; events but I&rsquo;m oblivious to what that
reference meant.
Decompilation
We start off with downloading the binary and opening it in Ghidra.
In the list of functions under the Symbol Tree, we can navigate to the entry function which looks like:'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel="preload stylesheet" href=../../header.svg><noscript><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/noscript.min.css></noscript><link rel=preload as=font href=https://lavafroth.is-a.dev/LeagueGothic.ttf><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body class=not-ready data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/>lavafroth</a></h1><svg id="btnDark" class="btn-dark" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 60 60" preserveAspectRatio="xMinYMin meet"><path class="circle" d="M30 16c7.73.0 14 6.27 14 14 0 3.81-1.53 7.27-4 9.8-2.54 2.59-6.08 4.2-10 4.2-7.73.0-14-6.27-14-14 0-7.73 6.27-14 14-14z"/><g class="rays" data-svg-origin="30 30"><line class="line" x1="30" y1="11" x2="30" y2="7"/><line class="line" x1="43.44" y1="16.57" x2="46.26" y2="13.74"/><line class="line" x1="49" y1="30" x2="53" y2="30"/><line class="line" x1="43.43" y1="43.44" x2="46.26" y2="46.26"/><line class="line" x1="30" y1="49" x2="30" y2="53"/><line class="line" x1="16.56" y1="43.43" x2="13.74" y2="46.26"/><line class="line" x1="11" y1="30" x2="7" y2="30"/><line class="line" x1="16.57" y1="16.56" x2="13.74" y2="13.74"/></g></svg><div class=space></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><script>const bodyClx=document.body.classList,sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>(bodyClx.toggle("dark",e),localStorage.setItem("dark",e));setDark(darkVal?darkVal==="true":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",({matches:e})=>setDark(e))</script></header><main class=main><article class=post-single><header class=post-title><p><time>Jul 21, 2023 | 13 minutes read</time></p><h1 data-pagefind-meta=title>Volcano</h1></header><section class=post-content data-pagefind-body><p>This reversing challenge is very mathematical, focusing mainly on modulo congruences.
Like all challenges, there is some scary looking obfuscation for the fun which I&rsquo;ll try my best to
explain. The challenge description says that it was <em>inspired by recent &ldquo;traumatic&rdquo; events</em> but I&rsquo;m oblivious to what that
reference meant.</p><h2 id=decompilation>Decompilation</h2><p>We start off with downloading the binary and opening it in Ghidra.</p><p>In the list of functions under the Symbol Tree, we can navigate to the <code>entry</code> function which looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>void</span> processEntry <span style=color:#a6e22e>entry</span>(undefined8 param_1,undefined8 param_2)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  undefined auStack_8 [<span style=color:#ae81ff>8</span>];
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>__libc_start_main</span>(FUN_001014a7,param_2,<span style=color:#f92672>&amp;</span>stack0x00000008,FUN_00101760,FUN_001017d0,param_1,auStack_8);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>/* WARNING: Do nothing block with infinite loop */</span>
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>while</span>( true );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice the call to <code>__libc_start_main</code>, the first argument supplied is a function pointer which points to the main function.</p><p>I have a habit of renaming variables in Ghidra so that they make some sense. I will rename this function to <code>main</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#a6e22e>__libc_start_main</span>(main,param_2,<span style=color:#f92672>&amp;</span>stack0x00000008,FUN_00101760,FUN_001017d0,param_1,auStack_8);
</span></span></code></pre></div><h3 id=main><code>main</code></h3><p>If we double click on the newly renamed <code>main</code> function, we will see a function that has a massive cyclomatic complexity in the decompiler view.
I will try to make this more sensible by selecting the generated identifiers, then renaming (pressing <code>L</code>) and retyping (<code>Ctrl</code> <code>L</code>).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> ok;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>bool</span> _ok;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> ret;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> n_volcano;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> n_bear;
</span></span><span style=display:flex><span>  ulong m_v;
</span></span><span style=display:flex><span>  ulong m_b;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> fs_register;
</span></span><span style=display:flex><span>  ulong bear;
</span></span><span style=display:flex><span>  ulong volcano;
</span></span><span style=display:flex><span>  ulong proof;
</span></span><span style=display:flex><span>  ulong leet;
</span></span><span style=display:flex><span>  FILE <span style=color:#f92672>*</span>flag;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>char</span> buf [<span style=color:#ae81ff>136</span>];
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>long</span> canary;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  canary <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>)(fs_register <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x28</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setbuf</span>(stdin,(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#ae81ff>0x0</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setbuf</span>(stdout,(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#ae81ff>0x0</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>setbuf</span>(stderr,(<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)<span style=color:#ae81ff>0x0</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Give me a bear: &#34;</span>);
</span></span><span style=display:flex><span>  bear <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%llu&#34;</span>,<span style=color:#f92672>&amp;</span>bear);
</span></span><span style=display:flex><span>  ok <span style=color:#f92672>=</span> <span style=color:#a6e22e>process_bear</span>(bear);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (ok) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Give me a volcano: &#34;</span>);
</span></span><span style=display:flex><span>    volcano <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%llu&#34;</span>,<span style=color:#f92672>&amp;</span>volcano);
</span></span><span style=display:flex><span>    _ok <span style=color:#f92672>=</span> <span style=color:#a6e22e>process_volcano</span>(volcano);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (_ok) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Prove to me they are the same: &#34;</span>);
</span></span><span style=display:flex><span>      proof <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      leet <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x1337</span>;
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%llu&#34;</span>,<span style=color:#f92672>&amp;</span>proof);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (((proof <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>||</span> (proof <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;That</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>s not a valid proof!&#34;</span>);
</span></span><span style=display:flex><span>        ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        n_volcano <span style=color:#f92672>=</span> <span style=color:#a6e22e>n_digits</span>(volcano);
</span></span><span style=display:flex><span>        n_bear <span style=color:#f92672>=</span> <span style=color:#a6e22e>n_digits</span>(bear);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (n_volcano <span style=color:#f92672>==</span> n_bear) {
</span></span><span style=display:flex><span>          n_volcano <span style=color:#f92672>=</span> <span style=color:#a6e22e>sum_of_digits</span>(volcano);
</span></span><span style=display:flex><span>          n_bear <span style=color:#f92672>=</span> <span style=color:#a6e22e>sum_of_digits</span>(bear);
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (n_volcano <span style=color:#f92672>==</span> n_bear) {
</span></span><span style=display:flex><span>            m_v <span style=color:#f92672>=</span> <span style=color:#a6e22e>check_proof</span>(leet,volcano,proof);
</span></span><span style=display:flex><span>            m_b <span style=color:#f92672>=</span> <span style=color:#a6e22e>check_proof</span>(leet,bear,proof);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (m_v <span style=color:#f92672>==</span> m_b) {
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;That looks right to me!&#34;</span>);
</span></span><span style=display:flex><span>              flag <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(<span style=color:#e6db74>&#34;flag.txt&#34;</span>,<span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>fgets</span>(buf,<span style=color:#ae81ff>0x80</span>,flag);
</span></span><span style=display:flex><span>              <span style=color:#a6e22e>puts</span>(buf);
</span></span><span style=display:flex><span>              ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>              <span style=color:#66d9ef>goto</span> LAB_00101740;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;Nope that</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>s not right!&#34;</span>);
</span></span><span style=display:flex><span>        ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;That doesn</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>t look like a volcano!&#34;</span>);
</span></span><span style=display:flex><span>      ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;That doesn</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>t look like a bear!&#34;</span>);
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>LAB_00101740:
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (canary <span style=color:#f92672>!=</span> <span style=color:#f92672>*</span>(<span style=color:#66d9ef>long</span> <span style=color:#f92672>*</span>)(fs_register <span style=color:#f92672>+</span> <span style=color:#ae81ff>0x28</span>)) {
</span></span><span style=display:flex><span>                    <span style=color:#75715e>/* WARNING: Subroutine does not return */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>__stack_chk_fail</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The program asks for an unsigned long integer as a bear. It calls a subroutine to process the integer
and stores the result in the <code>ok</code> variable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Give me a bear: &#34;</span>);
</span></span><span style=display:flex><span>bear <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%llu&#34;</span>,<span style=color:#f92672>&amp;</span>bear);
</span></span><span style=display:flex><span>ok <span style=color:#f92672>=</span> <span style=color:#a6e22e>process_bear</span>(bear);
</span></span></code></pre></div><p>The next block only executes when <code>ok</code> is true.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>if</span> (ok) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Inside this block, the program for another unsigned long integer as before but calls it a volcano, running
a check specific to this input.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Give me a volcano: &#34;</span>);
</span></span><span style=display:flex><span>volcano <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%llu&#34;</span>,<span style=color:#f92672>&amp;</span>volcano);
</span></span><span style=display:flex><span>_ok <span style=color:#f92672>=</span> <span style=color:#a6e22e>process_volcano</span>(volcano);
</span></span></code></pre></div><p>The next conditional block executes when this <code>process_volcano</code> subroutine return true.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>if</span> (_ok) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>The program then asks for another unsigned long integer as a proof for the <em>&ldquo;volcano&rdquo;</em> and the <em>&ldquo;bear&rdquo;</em> being the same.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Prove to me they are the same: &#34;</span>);
</span></span><span style=display:flex><span>proof <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>leet <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x1337</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>scanf</span>(<span style=color:#e6db74>&#34;%llu&#34;</span>,<span style=color:#f92672>&amp;</span>proof);
</span></span></code></pre></div><p>If the proof value&rsquo;s last bit (<code>proof & 1</code>) is 0, meaning if the proof is even or it is 1, we get the bad ending
that says, &ldquo;That&rsquo;s not a valid proof!&rdquo;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>if</span> (((proof <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>||</span> (proof <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;That</span><span style=color:#ae81ff>\&#39;</span><span style=color:#e6db74>s not a valid proof!&#34;</span>);
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For the good ending, we check what&rsquo;s in the <code>else</code> block.</p><p>Here, I have renamed two functions to <code>n_digits</code> and <code>sum_of_digits</code> because that is exactly what they do.
There&rsquo;s nothing worth explaining about them in particular but you may check them if you are following along.</p><p>First we need the number of digits in the volcano and bear digits to be equal.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>n_volcano <span style=color:#f92672>=</span> <span style=color:#a6e22e>n_digits</span>(volcano);
</span></span><span style=display:flex><span>n_bear <span style=color:#f92672>=</span> <span style=color:#a6e22e>n_digits</span>(bear);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (n_volcano <span style=color:#f92672>==</span> n_bear) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> }
</span></span></code></pre></div><p>Our second constraint is that the sum of the digits must equal for the volcano and the bear.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>n_volcano <span style=color:#f92672>=</span> <span style=color:#a6e22e>sum_of_digits</span>(volcano);
</span></span><span style=display:flex><span>n_bear <span style=color:#f92672>=</span> <span style=color:#a6e22e>sum_of_digits</span>(bear);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (n_volcano <span style=color:#f92672>==</span> n_bear) {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Finally the happy ending happens when the result of a proof checking function is the same for both the numbers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>m_v <span style=color:#f92672>=</span> <span style=color:#a6e22e>check_proof</span>(leet,volcano,proof);
</span></span><span style=display:flex><span>m_b <span style=color:#f92672>=</span> <span style=color:#a6e22e>check_proof</span>(leet,bear,proof);
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (m_v <span style=color:#f92672>==</span> m_b) {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>puts</span>(<span style=color:#e6db74>&#34;That looks right to me!&#34;</span>);
</span></span><span style=display:flex><span>  flag <span style=color:#f92672>=</span> <span style=color:#a6e22e>fopen</span>(<span style=color:#e6db74>&#34;flag.txt&#34;</span>,<span style=color:#e6db74>&#34;r&#34;</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fgets</span>(buf,<span style=color:#ae81ff>0x80</span>,flag);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>puts</span>(buf);
</span></span><span style=display:flex><span>  ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>goto</span> LAB_00101740;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Now, I will visit the functions that I had glossed over earlier.</p><h3 id=process_bear><code>process_bear</code></h3><p>The decompilation looks like the following after some renaming and cleanup.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>process_bear</span>(ulong b) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> ((b <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>%</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>%</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>+</span> ((b <span style=color:#f92672>-</span> b <span style=color:#f92672>/</span> <span style=color:#ae81ff>7</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> b <span style=color:#f92672>/</span> <span style=color:#ae81ff>7</span> <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>*</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>7</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>%</span> <span style=color:#ae81ff>0x6d</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x37</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function gives us the constraints for the unsigned long integer represented by &ldquo;bear&rdquo;.
The function only returns true when all of the following conditions are met by the number:</p><ul><li>The last bit is zero (<code>b & 1 == 0</code>), meaning, it is even.</li><li>When divided by 3, yields the remainder of 2.</li><li>When divided by 5, yields the remainder of 1.</li><li>When divided by 0x6d, yields the remainder of 0x37.</li><li>The madness that is <code>b + ((b - b / 7 >> 1) + b / 7 >> 2) * -7 == 3</code></li></ul><p>Okay, calm down, the last part is not very hard to decipher. Let&rsquo;s work it out piece by piece.</p><p>The right shift operation (<code>>></code>) implies division by 2 to the power of something. So the innermost parenthetic expression
<code>b - b / 7 >> 1</code> means to divide <code>b - b / 7</code> by 2 to the power of 1.</p><p>When considered as a purely mathematical expression, we can perform the following simplification.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>b</mi><mo>−</mo><mn>7</mn><mo>×</mo><mfrac><mn>1</mn><msup><mn>2</mn><mn>2</mn></msup></mfrac><mo stretchy="false">(</mo><mfrac><mn>1</mn><msup><mn>2</mn><mn>1</mn></msup></mfrac><mo stretchy="false">(</mo><mi>b</mi><mo>−</mo><mfrac><mi>b</mi><mn>7</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>b</mi><mn>7</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> b - 7 \times \frac{1}{2^2}(\frac{1}{2^1}(b-\frac{b}{7}) + \frac{b}{7}) </annotation></semantics></math></span><p></p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mi>b</mi><mo>−</mo><mfrac><mn>7</mn><mn>4</mn></mfrac><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo stretchy="false">(</mo><mfrac><mrow><mn>6</mn><mi>b</mi></mrow><mn>7</mn></mfrac><mo stretchy="false">)</mo><mo>+</mo><mfrac><mi>b</mi><mn>7</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> = b - \frac{7}{4}(\frac{1}{2}(\frac{6b}{7}) + \frac{b}{7}) </annotation></semantics></math></span><p></p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mi>b</mi><mo>−</mo><mfrac><mn>7</mn><mn>4</mn></mfrac><mo stretchy="false">(</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>×</mo><mfrac><mrow><mn>6</mn><mi>b</mi></mrow><mn>7</mn></mfrac><mo>+</mo><mfrac><mi>b</mi><mn>7</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> = b - \frac{7}{4}(\frac{1}{2} \times \frac{6b}{7} + \frac{b}{7}) </annotation></semantics></math></span><p></p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mi>b</mi><mo>−</mo><mfrac><mn>7</mn><mn>4</mn></mfrac><mo stretchy="false">(</mo><mfrac><mrow><mn>3</mn><mi>b</mi></mrow><mn>7</mn></mfrac><mo>+</mo><mfrac><mi>b</mi><mn>7</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> = b - \frac{7}{4}(\frac{3b}{7} + \frac{b}{7}) </annotation></semantics></math></span><p></p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mi>b</mi><mo>−</mo><mfrac><mn>7</mn><mn>4</mn></mfrac><mo stretchy="false">(</mo><mfrac><mrow><mn>4</mn><mi>b</mi></mrow><mn>7</mn></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> = b - \frac{7}{4}(\frac{4b}{7}) </annotation></semantics></math></span><p>We can cancel the 4s in the numerator since they were results of the shift operations.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>=</mo><mi>b</mi><mo>−</mo><mn>7</mn><mo>×</mo><mfrac><mi>b</mi><mn>7</mn></mfrac></mrow><annotation encoding="application/x-tex"> = b - 7 \times \frac{b}{7} </annotation></semantics></math></span><p>However, we cannot cancel out the 7s since they were part of the C division.
Remember, the divison operation in C results in the truncated integer quotient, not a floating point number.
This means <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>7</mn><mo>×</mo><mfrac><mi>b</mi><mn>7</mn></mfrac></mrow><annotation encoding="application/x-tex"> 7 \times \frac{b}{7} </annotation></semantics></math></span> here gives us the largest multiple of 7 below <code>b</code>.</p><p>Another way to think of it is the part of <code>b</code> that is divisible by 7, leaving out the remainder.</p><p>When we subtract this from the original number, we get what was left out, the remainder itself!</p><p>The entire condition simplifies to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span>b <span style=color:#f92672>%</span> <span style=color:#ae81ff>7</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><p>This will be another constraint for the <code>bear</code> number.</p><h3 id=process_volcano><code>process_volcano</code></h3><p>The decompilation after renames and cleanups looks like the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>process_volcano</span>(<span style=color:#66d9ef>uint64_t</span> v) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> total_bits <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint64_t</span> i <span style=color:#f92672>=</span> v; i <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>=</span> i <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    total_bits <span style=color:#f92672>=</span> total_bits <span style=color:#f92672>+</span> (i <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (total_bits <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0x11</span>) <span style=color:#f92672>&amp;&amp;</span> (total_bits <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0x1b</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here the program loops over the bits in the number supplied and counts the ones that are high.
The function only returns a true value when the total number of high bits is between 17 (0x11, inclusive) and 27 (0x1b, exclusive).</p><p>This is a constraint for the <code>volcano</code> number.</p><h3 id=check_proof><code>check_proof</code></h3><p>As usual, I have cleaned some of the code, renamed a bunch of variables for them to make sense.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>uint64_t</span> <span style=color:#a6e22e>check_proof</span>(<span style=color:#66d9ef>uint64_t</span> leet, <span style=color:#66d9ef>uint64_t</span> v, <span style=color:#66d9ef>uint64_t</span> proof) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> ret <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, mod <span style=color:#f92672>=</span> leet <span style=color:#f92672>%</span> proof;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>uint64_t</span> i <span style=color:#f92672>=</span> v; i <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>=</span> i <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>      ret <span style=color:#f92672>=</span> (ret <span style=color:#f92672>*</span> mod) <span style=color:#f92672>%</span> proof;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    mod <span style=color:#f92672>=</span> (mod <span style=color:#f92672>*</span> mod) <span style=color:#f92672>%</span> proof;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> ret;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function begins by defining a return variable as 1 and another variable <code>mod</code> as result of the <code>leet</code> modulo the proof value. I have renamed this
variable leet since 0x1337 is the only number supplied as the argument throughout the program.</p><p>It then loops over the bits of the argument <code>v</code>. If a given bit is high, the return value gets assigned itself multiplied by the <code>mod</code>, modulo the proof value.
Otherwise, the <code>mod</code> variable gets assigned itself squared, modulo the proof.</p><p>Recall that the result of this function must be equal for both the <code>volcano</code> and the <code>bear</code> number.</p><p>How do we make sure that the results are equal if there is so much of pseudo-randomness involved?</p><p>Our best option is to somehow have the <code>mod</code> variable as 1 since anything times 1 is itself.
The return value in such a case is bound to its initial value of 1 for any non-zero proof value.</p><p>For this to happen, <code>leet % proof</code> must be equal to 1. Let&rsquo;s call the proof <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>.<br>With 0x1337 being the only value passed as <code>leet</code>,
we have the constraint</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>0</mn><mi>x</mi><mn>1337</mn><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">0x1337 \equiv 1 \pmod{p}</annotation></semantics></math></span><p>Let&rsquo;s convert the hexadecimal number to decimal.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>4919</mn><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">4919 \equiv 1 \pmod{p}</annotation></semantics></math></span><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mn>4919</mn><mo>−</mo><mn>1</mn><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\implies 4919 - 1 \equiv 0 \pmod{p}</annotation></semantics></math></span><p></p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>  </mtext><mo>⟹</mo><mtext>  </mtext><mn>4918</mn><mo>≡</mo><mn>0</mn><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>p</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\implies 4918 \equiv 0 \pmod{p}</annotation></semantics></math></span><p>Earlier, we noted that the proof value cannot be 1 and it cannot be even.<br>It is of the form <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow><annotation encoding="application/x-tex"> 2n + 1, n \in \mathbb{N} </annotation></semantics></math></span></p><p>Thus, we need an odd proof value that divides 4918 without leaving any remainder.</p><p>The number 2 divides 4918 to give 2459, a prime number.</p><p>This implies, 2 and 2459 are the prime factors of 4918. Since 2 is even, we will choose <strong>2459</strong> as the proof value.</p><h2 id=solving-for-the-volcano-and-the-bear>Solving for the <code>volcano</code> and the <code>bear</code></h2><p>I will be writing a little Rust program to solve for the remaining constraints.</p><p>We know that the <code>volcano</code> number must have at least 17 high bits and at most 27 high bits. Hence, we will begin by
generating numbers that have 17 high bits and 1 low bit.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> ones <span style=color:#f92672>=</span> <span style=color:#ae81ff>17</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> bits <span style=color:#f92672>=</span> ones <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> volcanos <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>bits)
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>position<span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> position) <span style=color:#f92672>^</span> ((<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bits) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;&gt;</span>();
</span></span></code></pre></div><p>This gives us numbers that have a binary representation like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#ae81ff>111111111111111110</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>111111111111111101</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>111111111111111011</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>111111111111110111</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// and so on
</span></span></span></code></pre></div><p>For any of these numbers we wish to find a <code>bear</code> number that:</p><ul><li>is even</li><li>yields the remainder of 2 when divided by 3</li><li>yields the remainder of 1 when divided by 5</li><li>yields the remainder of 3 when divided by 7</li><li>yields the remainder of 55 when divided by 109</li><li>has the same number of digits as the <code>volcano</code></li><li>has the same sum of digits as the <code>volcano</code></li></ul><p>The naive, inefficient solution would be to loop from 1 to infinity and check for each condition manually.
The code would look like the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> bear <span style=color:#66d9ef>in</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>..</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> bear <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&amp;&amp;</span> bear <span style=color:#f92672>%</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&amp;&amp;</span> bear <span style=color:#f92672>%</span> <span style=color:#ae81ff>5</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&amp;&amp;</span> bear <span style=color:#f92672>%</span> <span style=color:#ae81ff>7</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&amp;&amp;</span> bear <span style=color:#f92672>%</span> <span style=color:#ae81ff>109</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>55</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>&amp;&amp;</span> sum_and_number_of_digits(bear) <span style=color:#f92672>==</span> sum_and_number_of_digits(volcano)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do something
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Since most of the conditions are modulo congruence checks, we can use the Chinese Remainder Theorem
to solve for the smallest number that leaves the respective remainders and begin from there.</p><p>Let <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span> be a vector of all the moduli and <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span> represent the array of the respective remainders.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>5</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>7</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>109</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">
a = \begin{bmatrix}
2 &amp; 3 &amp; 5 &amp; 7 &amp; 109
\end{bmatrix}
</annotation></semantics></math></span><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>r</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>3</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>55</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">
r = \begin{bmatrix}
0 &amp; 2 &amp; 1 &amp; 3 &amp; 55
\end{bmatrix}
</annotation></semantics></math></span><p>We begin by calculating <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span>, the product of all the moduli.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo>=</mo><mo>∏</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">
n = \prod{a}
</annotation></semantics></math></span><p>We construct <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span> containing the modulus of each equation by diving <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span> by each element of <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span>.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>=</mo><mfrac><mi>n</mi><msub><mi>a</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">
m_{i} = \frac{n}{a_{i}}
</annotation></semantics></math></span><p>We then calculate the multiplicative modular inverse of the aforementioned moduli with respect to the original moduli.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>M</mi><mi>i</mi></msub><mo>≡</mo><mfrac><mn>1</mn><msub><mi>m</mi><mi>i</mi></msub></mfrac><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
M_{i} \equiv \frac{1}{m_{i}} \pmod{a_i}
</annotation></semantics></math></span><blockquote><p>The modular inverse of a number <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span> modulo <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span> is the number <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>i</mi><mi>n</mi><mi>v</mi></mrow></msub></mrow><annotation encoding="application/x-tex">x_{inv}</annotation></semantics></math></span> such that</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo>⋅</mo><msub><mi>x</mi><mrow><mi>i</mi><mi>n</mi><mi>v</mi></mrow></msub><mo>≡</mo><mn>1</mn><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> x \cdot x_{inv} \equiv 1 \pmod{m} </annotation></semantics></math></span></blockquote><p>We now multiply the calculated moduli and their inverses to find out the constants that leave the remainder 1.
Let&rsquo;s name this array of constants as <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi></mrow><annotation encoding="application/x-tex">c</annotation></semantics></math></span>.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mi>m</mi><mi>i</mi></msub><mo>⋅</mo><msub><mi>M</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex"> c_{i} = m_{i} \cdot M_{i} </annotation></semantics></math></span><p>We multiply the remainder with each constant and add them up. The final unique solution <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span> is this number modulo <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span>.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>s</mi><mo>=</mo><mo stretchy="false">(</mo><munder><mo>∑</mo><mi>i</mi></munder><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>⋅</mo><msub><mi>r</mi><mi>i</mi></msub></mrow><mo stretchy="false">)</mo><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> s = (\sum_{i}{c_{i} \cdot r_{i}}) \pmod{n} </annotation></semantics></math></span><p>The code implementation looks like the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> moduli <span style=color:#f92672>=</span> [<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>109</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> remainders <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>55</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> n: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> moduli.iter().product();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> generated: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> moduli.iter().map(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> n <span style=color:#f92672>/</span> m).collect();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> inverses: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> generated
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .zip(moduli.iter())
</span></span><span style=display:flex><span>    .filter_map(<span style=color:#f92672>|</span>(a, m)<span style=color:#f92672>|</span> modinverse::modinverse(<span style=color:#f92672>*</span>a, <span style=color:#f92672>*</span>m))
</span></span><span style=display:flex><span>    .collect();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> s: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> inverses
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .zip(generated.iter())
</span></span><span style=display:flex><span>    .zip(remainders.iter())
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>((m, m_inv), r)<span style=color:#f92672>|</span> m <span style=color:#f92672>*</span> m_inv <span style=color:#f92672>*</span> r)
</span></span><span style=display:flex><span>    .sum();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> solution <span style=color:#f92672>=</span> s <span style=color:#f92672>%</span> n;
</span></span></code></pre></div><p>For convenience, I&rsquo;m using the <a href=https://docs.rs/modinverse/latest/modinverse/>modinverse</a> crate. If you are following along,
run the following to add it to your Rust project:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo add modinverse
</span></span></code></pre></div><p>For all the <code>volcano</code> numbers generated we search for a <code>bear</code> number starting from the unique <code>solution</code> and stepping by the product of all the moduli, <code>n</code>.
Again, if any of the <code>bear</code> values has the same number of digits and the same sum of digits as the volcano number, it is valid.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> volcano <span style=color:#66d9ef>in</span> volcanos {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> v_digits <span style=color:#f92672>=</span> digits(volcano);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> bear <span style=color:#66d9ef>in</span> (solution<span style=color:#f92672>..</span>volcano).step_by(n <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> digits(bear) <span style=color:#f92672>==</span> v_digits {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;volcano: </span><span style=color:#e6db74>{volcano}</span><span style=color:#e6db74>, bear: </span><span style=color:#e6db74>{bear}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here <code>digits</code> is a function that returns a tuple of the number of digits and sum of digits for an argument.</p><p>The complete program source code becomes the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>digits</span>(<span style=color:#66d9ef>mut</span> n: <span style=color:#66d9ef>i32</span>) -&gt; (<span style=color:#66d9ef>i32</span>, <span style=color:#66d9ef>i32</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> c <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> r <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> n <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        r <span style=color:#f92672>+=</span> n <span style=color:#f92672>%</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>        n <span style=color:#f92672>/=</span> <span style=color:#ae81ff>10</span>;
</span></span><span style=display:flex><span>        c <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    (c, r)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> ones <span style=color:#f92672>=</span> <span style=color:#ae81ff>17</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> bits <span style=color:#f92672>=</span> ones <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> volcanos <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>bits)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>position<span style=color:#f92672>|</span> (<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> position) <span style=color:#f92672>^</span> ((<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> bits) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>        .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;&gt;</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> moduli <span style=color:#f92672>=</span> [<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>109</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> remainders <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>55</span>];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> n: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> moduli.iter().product();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> generated: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> moduli.iter().map(<span style=color:#f92672>|</span>m<span style=color:#f92672>|</span> n <span style=color:#f92672>/</span> m).collect();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> inverses: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i32</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> generated
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .zip(moduli.iter())
</span></span><span style=display:flex><span>        .filter_map(<span style=color:#f92672>|</span>(a, m)<span style=color:#f92672>|</span> modinverse::modinverse(<span style=color:#f92672>*</span>a, <span style=color:#f92672>*</span>m))
</span></span><span style=display:flex><span>        .collect();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> constants_sum: <span style=color:#66d9ef>i32</span> <span style=color:#f92672>=</span> inverses
</span></span><span style=display:flex><span>        .iter()
</span></span><span style=display:flex><span>        .zip(generated.iter())
</span></span><span style=display:flex><span>        .zip(remainders.iter())
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>((m, m_inv), r)<span style=color:#f92672>|</span> m <span style=color:#f92672>*</span> m_inv <span style=color:#f92672>*</span> r)
</span></span><span style=display:flex><span>        .sum();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> solution <span style=color:#f92672>=</span> constants_sum <span style=color:#f92672>%</span> n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> volcano <span style=color:#66d9ef>in</span> volcanos {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> v_digits <span style=color:#f92672>=</span> digits(volcano);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> bear <span style=color:#66d9ef>in</span> (solution<span style=color:#f92672>..</span>volcano).step_by(n <span style=color:#66d9ef>as</span> <span style=color:#66d9ef>usize</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> digits(bear) <span style=color:#f92672>==</span> v_digits {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;volcano: </span><span style=color:#e6db74>{volcano}</span><span style=color:#e6db74>, bear: </span><span style=color:#e6db74>{bear}</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If we run the program using <code>cargo run</code>, we get multiple unqiue solutions to the problem:</p><pre tabindex=0><code>volcano: 262139, bear: 132926
volcano: 262139, bear: 201596
volcano: 262079, bear: 155816
volcano: 262079, bear: 224486
volcano: 258047, bear: 155816
volcano: 258047, bear: 224486
volcano: 196607, bear: 178706
</code></pre><p>Now we can connect to the challenge server, supply any of the solutions and get the flag.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>nc amt.rs <span style=color:#ae81ff>31010</span>
</span></span></code></pre></div><pre tabindex=0><code>Give me a bear: 132926
Give me a volcano: 262139
Prove to me they are the same: 2459
That looks right to me!
amateursCTF{yep_th0se_l00k_th3_s4me_to_m3!_:clueless:}
</code></pre></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/amateursctf class=list-tag>AmateursCTF</a>
<a href=https://lavafroth.is-a.dev/tags/ctf class=list-tag>CTF</a>
<a href=https://lavafroth.is-a.dev/tags/remainder-theorem class=list-tag>Remainder Theorem</a>
<a href=https://lavafroth.is-a.dev/tags/reverse-engineering class=list-tag>Reverse Engineering</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/compact-xor-crypto-challenge-amateursctf-2023/><span>←</span><span>Compact XOR</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/wait-an-eternity-web-challenge-amateursctf-2023/><span>Waiting an Eternity</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>