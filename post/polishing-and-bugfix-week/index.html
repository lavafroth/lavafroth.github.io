<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Polishing and Bugfix Week - lavafroth</title><meta name=description content='Hello and welcome to the last instalment in the series where we build a parser
for a domain specific langauge in Rust. Please go through the previous articles
since this article assumes you are aware of such contextual details.
Let&rsquo;s start with the bugfixes.
Eagerly removing unbinds
While going through the tests, I figured that
the prior parser eagerly parses unbinds and removes said keystroke combinations
from our binding set. Unlike the previous iteration, our iteration had unbinds
as a separate set which deferred the task of the removing the set intersection
to the upstream crate instead.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link rel=preload as=font href=https://lavafroth.is-a.dev/LeagueGothic.ttf><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/>lavafroth</a></h1><div class=push></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a></header><main class=main><article class=post-single><header class=post-title><p><time>Jul 29, 2024 | 4 minutes read</time></p><h1 data-pagefind-meta=title>Polishing and Bugfix Week</h1></header><section class=post-content data-pagefind-body><p>Hello and welcome to the last instalment in the series where we build a parser
for a domain specific langauge in Rust. Please go through the previous articles
since this article assumes you are aware of such contextual details.</p><p>Let&rsquo;s start with the bugfixes.</p><h1 id=eagerly-removing-unbinds>Eagerly removing unbinds</h1><p>While going through the tests, I figured that
the prior parser eagerly parses unbinds and removes said keystroke combinations
from our binding set. Unlike the previous iteration, our iteration had unbinds
as a separate set which deferred the task of the removing the set intersection
to the upstream crate instead.</p><p>To fix this, we follow the good old adage, <em>&ldquo;fix it in post&rdquo;</em>. With the import
functionality taking care of duplicate imports, all imports are parsed using
the private <code>SwhkdParser::as_import</code> function, passing in the respective inputs as
well as a state struct to keep track of imports we&rsquo;ve already seen. The only
exception to this rule is for the root of all the imports. For the root config,
we have a <code>from</code> function that accepts a single input (raw text or path) and repeatedly
uses the <code>as_import</code> function on all subsequent inputs.</p><p>Since we know that the upstream crate will only be able to use the public <code>from</code> function,
we can add the fix right after every import has been parsed. We add the following
loop to remove any binding in our binding list as long as it also exists in the
unbinds list.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> def <span style=color:#66d9ef>in</span> root.unbinds.iter() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(i) <span style=color:#f92672>=</span> root.bindings.iter().position(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.definition.eq(def)) {
</span></span><span style=display:flex><span>        root.bindings.remove(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=overwriting-bindings-that-are-redefined>Overwriting bindings that are redefined</h1><p>I had a talk with my GSoC mentor last week where we discussed whether bindings
from imports that get redefined in the root config should be overwritten. After
some back and forth, we decided to stick with the older behavior of overwriting.</p><p>To implement this, instead of blindly extending the list of bindings with what
has been parsed, we check if a binding with the same definition exists. If so,
we replace the binding&rsquo;s command with the new command.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> binding <span style=color:#66d9ef>in</span> binding_parser(decl)<span style=color:#f92672>?</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(b) <span style=color:#f92672>=</span> bindings
</span></span><span style=display:flex><span>        .iter_mut()
</span></span><span style=display:flex><span>        .find(<span style=color:#f92672>|</span>b<span style=color:#f92672>|</span> b.definition <span style=color:#f92672>==</span> binding.definition)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        b.command <span style=color:#f92672>=</span> binding.command;
</span></span><span style=display:flex><span>        b.mode_instructions <span style=color:#f92672>=</span> binding.mode_instructions;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        bindings.push(binding);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=unescaping-commands-in-shorthands>Unescaping commands in shorthands</h1><p>This one&rsquo;s a fairly straightforward one but I probably would have missed it if it
were not for the tests. The commands, just like keys, must be unescaped when present
in shorthands. This is so that we can distinguish a comma separating two
shorthand elements or a dash representing a range from a literal comma or a dash.</p><p>Solution? Simply reuse the unescape function we used in for the keys.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Rule::command_component <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    command_variants.push(unescape(component.as_str()).to_string())
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>// ...
</span></span></span></code></pre></div><h1 id=removing-trailing-double-ampersands-from-commands>Removing trailing double ampersands from commands</h1><p>When defining commands for bindings, swhkd allows us to chain commands with
double ampersands (<code>&&</code>). Not only that, we can also invoke modes with special
syntax. If the <code>&&</code> is followed by a <code>@enter</code> and a modename, we enter a mode
whereas a <code>@escape</code> allows us to exit a mode.</p><p>In a previous article where we built a way to extract these modes during a single
pass iteration, we extract the mode instruction to our list of mode instructions
and if the last component was not a <code>&&</code>, we keep the <code>&&</code>.</p><p>This idea was somewhat flawed since and expression like the following keeps an
extra trailing <code>&&</code>.</p><pre tabindex=0><code>echo hi &amp;&amp; ls &amp;&amp; @enter mymode
</code></pre><p>Clearly, the last <code>&&</code> has no problem staying beside the <code>ls</code> while the <code>@enter</code>
mode instruction was happily extracted away. The result <code>echo hi && ls &&</code> isn&rsquo;t
a valid command though.</p><p>To fix this, we add a small snippet of code to pop off the last element if it happens
to be just one <code>&&</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> comm
</span></span><span style=display:flex><span>    .last()
</span></span><span style=display:flex><span>    .is_some_and(<span style=color:#f92672>|</span>last<span style=color:#f92672>|</span> last.len() <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> last[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;&amp;&amp;&#34;</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    comm.pop();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=wrapping-up>Wrapping up</h1><p>So yeah, those were the small bugs that needed to be squashed and with that all
the previous tests as well as new tests are passing. This also marks the end of
the development phase on my end. Perhaps in a next post, I&rsquo;ll talk about how I
actually use SWHKD in my daily workflows. Stay tuned!</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/how-i-use-swhkd-in-my-workflow/><span>←</span><span>How I Use SWHKD in My Workflow</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/humans-suck-at-command-sanitization/><span>Humans Suck at Command Sanitization</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>