<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Humans Suck at Command Sanitization - lavafroth</title><meta name=description content='Hello and welcome to the eighth instalment in the series where we build a parser
for a domain specific language in Rust. I’d highly recommend going through the
previous articles to make sense of what we’ll talk about today.
Previously, we had built the scaffolding for modes to bind shortcuts to. Today,
we&rsquo;ll create the mechanism to invoke commands in the contexts of the modes that
can be built.
Now, SWHKD has a clever way to enter (and escape) mode contexts with inside commands
by chaining subcommands and mode instructions with double ampersands. Consider the following example:'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/rss.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body><header><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2400"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a><nav><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><a href=../../index.xml aria-label=rss style=--url:url(./rss.svg)></a><nav></header><main><article class=post-single data-pagefind-body><hgroup><p data-pagefind-ignore><time>Jul 17, 2024 | 4 minutes read</time></p><h1 data-pagefind-meta=title>Humans Suck at Command Sanitization</h1></hgroup><section class=post-content><p>Hello and welcome to the eighth instalment in the series where we build a parser
for a domain specific language in Rust. I’d highly recommend going through the
previous articles to make sense of what we’ll talk about today.</p><p>Previously, we had built the scaffolding for modes to bind shortcuts to. Today,
we&rsquo;ll create the mechanism to invoke commands in the contexts of the modes that
can be built.</p><p>Now, SWHKD has a clever way to enter (and escape) mode contexts with inside commands
by chaining subcommands and mode instructions with double ampersands. Consider the following example:</p><pre tabindex=0><code>super + a
  ls &amp;&amp; @enter mysecretmode &amp;&amp; cowsay &#39;hehe&#39; &amp;&amp; @escape
</code></pre><p>In the command for the above binding, we&rsquo;ll run the <code>ls</code> command followed by a double ampersand.
Anything following a double ampersand can either be a normal command or a mode instruction beginning
with an <code>@</code> sign. In our case, we have a mode instruction that asks the daemon to enter <code>mysecretmode</code>,
then we run the <code>cowsay</code> command and subsequently escape the mode using the <code>@escape</code> instruction.</p><p>Our goal for today is to modify the behavior of the command expression to account for this behavior.
Recall that we had already baked in the shorthand functionality into the command expression. Thus,
we need to be extra careful whem implementing this new behavior.</p><p>Since we&rsquo;ll need to negate the double ampersands because of the greedy algorithm used by pest, let&rsquo;s create
an expression for the double ampersands instead of having to use the literal string everywhere.</p><pre tabindex=0><code>command_double_ampersand = { &#34;&amp;&amp;&#34; }
</code></pre><p>First, let&rsquo;s create a model for a standalone subcommand that is neither a shorthand nor a mode instruction.</p><pre tabindex=0><code>command_standalone =  { (!shorthand_bounds ~ !command_double_ampersand ~ not_newline)+ }
</code></pre><p>Now any chunk that translates into a command after <em>&ldquo;compilation&rdquo;</em> is placed under the wrapper expression of
a <code>command_chunk</code>.</p><pre tabindex=0><code>command_chunk = _{ command_shorthand | command_standalone }
</code></pre><p>This includes the <code>command_standalone</code> expression since it compiles to itself without any
changes as well as the <code>command_shorthand</code> expression since it compiles into multiple variants of a subcommand.
Read the previous posts to see how those are implemented.</p><p>Now let&rsquo;s model the mode instructions. The <code>@enter</code> instruction requires a modename to actually enter. Thus, we&rsquo;ll
enforce that rule in the grammar as well.</p><pre tabindex=0><code>enter_mode =  { &#34;@enter&#34; ~ WHITESPACE ~ modename }
</code></pre><p>The <code>@escape</code> instruction on the other hand requires no modename since it just escapes the current mode.</p><pre tabindex=0><code>escape_mode =  { &#34;@escape&#34; }
</code></pre><p>Now to merge these two into a single expression, we&rsquo;ll make sure to trim off any excess whitespace between these
instructions and the double ampersands with a <code>WHITESPACE?</code> expression.</p><pre tabindex=0><code>mode_instruction = _{ WHITESPACE? ~ (enter_mode | escape_mode) ~ WHITESPACE? }
</code></pre><p>Contrary to these instructions, a standalone command or command shorthand will not trim any spaces since we can&rsquo;t
make any assumptions over whether the spaces are actually significant to the execution of the command itself.</p><p>Now anything between the double ampersands can either be a mode instruction or one or more of these command chunks.</p><pre tabindex=0><code>command_chunks_or_mode = _{ mode_instruction | (command_chunk*) }
</code></pre><p>The underscores before some of these expressions mean that they aren&rsquo;t public to the code side and are more of a
convenience for what we&rsquo;re about to build next. Finally, we can build an expression for a single line of command.</p><pre tabindex=0><code>command_line = _{ command_chunks_or_mode ~ (command_double_ampersand ~ command_chunks_or_mode)* }
</code></pre><p>Since a binding definition will always have the command indented with spaces, most text editors as well as a general
sense would suggest that multiline commands must also have each of their lines indented. Consider the same example
as before except that each subcommand is put on a new line.</p><pre tabindex=0><code>super + a
  ls \
  &amp;&amp; @enter mysecretmode \
  &amp;&amp; cowsay &#39;hehe&#39; \
  &amp;&amp; @escape
</code></pre><p>Notice the lines have equal indentation. For such multiline commands, we&rsquo;ll write a final expression to trim the
leading spaces for the commands to retain their semantics.</p><pre tabindex=0><code>command = ${ NEWLINE ~ WHITESPACE+ ~ command_line ~ (escape_lf ~ WHITESPACE+ ~ command_line)* }
</code></pre><p>The newline and whitespace is what comes immediately after a binding declaration (here, <code>super + a</code>). This is followed by a
line of command that can be run. The <code>WHITESPACE+</code> between the escaped line feed (trailing slash and newline) and the next
line of command is what trims out the leading spaces.</p><p>Okay, that was all for now. In the next post, I&rsquo;ll elaborate on how to extract these mode instructions sprinkled throughout
commands in the code side of this endeavor. See you around.</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/polishing-and-bugfix-week/><span>←</span><span>Polishing and Bugfix Week</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/><span>Preventing Infinite Recursions From Eating Your Lunch</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>