<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>A SWEET Little Parser - lavafroth</title><meta name=description content='A few days ago, I had announced my project for this year&rsquo;s Google Summer of Code. Today I&rsquo;ll
be explanding upon that. I believe that to construct a good grammar, I should be able to understand
and explain it well. So here goes.
General Idea
SWHKD&rsquo;s grammar parser, although similar to tools before it like sxhkd, has a more coherent
syntax. For starters, every binding declaration is one or more accelerators followed by a composite key.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2400"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a></h1><div class=push></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a></header><main class=main><article class=post-single><header class=post-title><p><time>May 17, 2024 | 4 minutes read</time></p><h1 data-pagefind-meta=title>A SWEET Little Parser</h1></header><section class=post-content data-pagefind-body><p>A few days ago, I had announced my project for this year&rsquo;s Google Summer of Code. Today I&rsquo;ll
be explanding upon that. I believe that to construct a good grammar, I should be able to understand
and explain it well. So here goes.</p><h2 id=general-idea>General Idea</h2><p>SWHKD&rsquo;s grammar parser, although similar to tools before it like sxhkd, has a more coherent
syntax. For starters, every binding declaration is one or more accelerators followed by a composite key.</p><p>The line following the binding declaration must be a tab or space indented command to be run by the client.</p><p>Here&rsquo;s a simple example to send a notification to myself using <code>libnotify</code> when I press <code>Super</code> <code>a</code>.</p><pre tabindex=0><code>super + a
  notify-send &#34;bazinga!&#34;
</code></pre><p>We can also issue multiline commands like we do in a normal shell by adding a bare backslash to the end
of each line. For example, the following binding checks if we have an Arduino connected and only then
sends a notification.</p><pre tabindex=0><code>super + a
  ls /dev/ttyACM0 &amp;&amp; \
  notify-send &#34;bazinga arduino baby!&#34;
</code></pre><p>This means we must ignore any trailing escaped line feeds and consider the two lines separated by them
as one.</p><p>Should be pretty simple right? Well, brace yourself for some added complexity: introducing shorthands!</p><h2 id=shorthands>Shorthands</h2><p>When it comes to bindings, a shorthand is two or more keys separated by commas inside curly braces.</p><pre tabindex=0><code>super + {a, b}
</code></pre><p>Each variant of these shorthands must correspond to a variation in the command following the declaration.
This naturally brings us to shorthands in commands. These are much more relaxed, each variant can be a
chunk of a command instead of being restricted to a list of valid keys and modifiers.</p><p>If a declaration has shorthands in it, the command following it must also have shorthands.</p><pre tabindex=0><code>super + {a, b}
  notify-send {&#34;you pressed a&#34;, &#34;you pressed b&#34;}
</code></pre><p>Although there exists a bash syntax to do similar shorthands, I like to think of SWHKD shorthands akin
to macros in Rust. Each binding <em>&ldquo;compiles&rdquo;</em> to the possible Cartesian products formed by multiplying
these variants.</p><p>To give you an example, a binding like this</p><pre tabindex=0><code>super + {ctrl, alt} + {a, b}
  notify-send {&#34;incoming&#34;, &#34;outgoing&#34;} {a, b}
</code></pre><p>would <em>&ldquo;compile&rdquo;</em> to the following four bindings:</p><pre tabindex=0><code>super + ctrl + a
  notify-send &#34;incoming&#34; a

super + ctrl + b
  notify-send &#34;incoming&#34; b

super + alt + a
  notify-send &#34;outgoing&#34; a

super + alt + b
  notify-send &#34;outgoing&#34; b
</code></pre><p><img src=../../swhkd-macro-compilation.gif alt="An animation showing how the shorthands are compiled"></p><p>Obviously we need to make sure that the keys are properly escaped inside these shorthands. For example a comma,
inside a shorthand acts as a separator. To specify a literal comma key, we would need
to consider an escaped comma like <code>\,</code> inside a shorthand. The same applies to the curly braces themselves.</p><p>Shorthands also allow omitting variants when it comes to modifiers. In such cases, the omissions are represented
by underscores and the plus sign usually outside the shorthand follows every non-empty variant. Take the following
example:</p><pre tabindex=0><code>super + {_, alt + } h
  {htop, btm}
</code></pre><p>This expands to the following bindings:</p><pre tabindex=0><code>super + h
  htop

super + alt + h
  btm
</code></pre><p>Notice that there is no extra logic to parse the concatenator (<code>+</code>) like we would need to
if the concatenator was outside the brace, because simply expanding the
shorthand set yields the correct outputs.</p><p>To not break this exception, we will model shorthands with omissions separate from regular
shorthands.</p><p>Now, what if you wanted to be even more succinct and define a bunch of shortcuts over a range
of keys? That&rsquo;s where the next puzzle piece comes into play.</p><h2 id=ranges>Ranges</h2><p>Ranges are technically a subset of shorthands, just as we have used commas so far to separate
each element of a shorthand, SWHKD allows the use of dashes to specify a range of keys.</p><p>For example, you can use ranges to switch to workspaces:</p><pre tabindex=0><code>super + {1-6}
  cosmic-workspaces switch {1-6}
</code></pre><p>This maps the keys 1 through 6 to those in the command to switch to the corresponding workspace.
Ranges can also be used with bare elements separated by commas like the following example:</p><pre tabindex=0><code>super + (a, 1-6)
  cosmic-workspaces switch {\-\-overview, 1-6}
</code></pre><p>Like the previous example, this one switches through workspaces 1 through 6 for the corresponding
keys. However, pressing <code>Super</code> <code>a</code> shows us an overview of all the workspaces.</p><p>Just like regular shorthands, we need to escape the dash used in the range. That&rsquo;s why, we&rsquo;re using the escaped
version of <code>--overview</code> flag.</p><p>The observations we have made so far will be used to build the grammar in the project.
The demo repo called <a href=https://github.com/lavafroth/sweet>sweet</a> (simple wayland event encoding text) is available <del>to my mentors for now but it should be public soon</del> publicly now.
<del>I need to double check and make sure my mentors are aware when I make it fully public.</del></p><p>In the next post I&rsquo;ll talk about defining the grammar for regular keys. See you then!</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/2-afternoons-2-languages-2-tuis/><span>←</span><span>2 Afternoons, 2 Languages, 2 TUIs</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/wayland-tools-rock/><span>Wayland Tools Rock!</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>