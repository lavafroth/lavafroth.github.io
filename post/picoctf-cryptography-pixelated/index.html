<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Pixelated - lavafroth</title><meta name=description content='This challenge gives use two images and asks us if we can make a flag out of them.
At first glance, both the images look like noise. Upon a quick web lookup of
visual cryptography, it appears
that these separate images, known as shares of the original image, can be overlayed
on each other to reconstruct the original image.
Exploration
Now, I&rsquo;m pretty sure that there are online services that will automatically solve these
but I decided to write some code to solve this locally. For the past week, I&rsquo;ve been
learning the Rust programming language and this was the perfect excuse to test my knowledge.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/rss.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body><header><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2400"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a><nav><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><a href=../../index.xml aria-label=rss style=--url:url(./rss.svg)></a><nav></header><main><article class=post-single data-pagefind-body><hgroup><p data-pagefind-ignore><time>Nov 22, 2022 | 2 minutes read</time></p><h1 data-pagefind-meta=title>Pixelated</h1></hgroup><section class=post-content><p>This challenge gives use two images and asks us if we can make a flag out of them.
At first glance, both the images look like noise. Upon a quick web lookup of
<a href=https://en.wikipedia.org/wiki/Visual_cryptography>visual cryptography</a>, it appears
that these separate images, known as shares of the original image, can be overlayed
on each other to reconstruct the original image.</p><h2 id=exploration>Exploration</h2><p>Now, I&rsquo;m pretty sure that there are online services that will automatically solve these
but I decided to write some code to solve this locally. For the past week, I&rsquo;ve been
learning the Rust programming language and this was the perfect excuse to test my knowledge.</p><p>First, we will create a cargo project. Let&rsquo;s call it &ldquo;solve&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo new solve
</span></span></code></pre></div><p>We&rsquo;ll then add the image library (crate) using cargo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo add image
</span></span></code></pre></div><div class=collapsable-explanation><div class=container><label><input type=checkbox></label></div><p>Now let&rsquo;s get some Rust in action. We&rsquo;ll start by editing the <code>src/main.rs</code> file.
First, we import the required types with the use statement.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> image::{GenericImageView, ImageBuffer, Pixel, RgbaImage};
</span></span></code></pre></div><p>We&rsquo;ll now write the main function. Let&rsquo;s open the images and store handles to them
in variables <code>a</code> and <code>b</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> image::open(<span style=color:#e6db74>&#34;scrambled1.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> image::open(<span style=color:#e6db74>&#34;scrambled2.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For sanity check, let&rsquo;s make sure that the dimensions are the same for both the images.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> a.dimensions() <span style=color:#f92672>!=</span> b.dimensions() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Image dimensions don&#39;t match.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, we&rsquo;ll create an image buffer for reconstructing the composite image.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> imgbuf: <span style=color:#a6e22e>RgbaImage</span> <span style=color:#f92672>=</span> ImageBuffer::new(a.width(), a.height());
</span></span></code></pre></div><p>Looping over the pixels in the shares,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> ((x, y, p), (_, _, q)) <span style=color:#66d9ef>in</span> a.pixels().zip(b.pixels()) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// next 2 code blocks go here ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>we sum the values in each channel &mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> pixel <span style=color:#f92672>=</span> p.channels()
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .zip(q.channels().iter())
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>(c0, c1)<span style=color:#f92672>|</span> c0.checked_add(<span style=color:#f92672>*</span>c1).unwrap_or(<span style=color:#f92672>*</span>c0))
</span></span><span style=display:flex><span>    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;&gt;</span>();
</span></span></code></pre></div><p>&mldr; and place the new pixel into the image buffer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>imgbuf.put_pixel(x, y, <span style=color:#f92672>*</span>Pixel::from_slice(<span style=color:#f92672>&amp;</span>pixel));
</span></span></code></pre></div><p>Finally, we save the image buffer into &ldquo;flag.png&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>imgbuf.save(<span style=color:#e6db74>&#34;flag.png&#34;</span>).unwrap();
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> image::open(<span style=color:#e6db74>&#34;scrambled1.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> image::open(<span style=color:#e6db74>&#34;scrambled2.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> a.dimensions() <span style=color:#f92672>!=</span> b.dimensions() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Image dimensions don&#39;t match.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> imgbuf: <span style=color:#a6e22e>RgbaImage</span> <span style=color:#f92672>=</span> ImageBuffer::new(a.width(), a.height());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ((x, y, p), (_, _, q)) <span style=color:#66d9ef>in</span> a.pixels().zip(b.pixels()) {
</span></span><span style=display:flex><span>        imgbuf.put_pixel(
</span></span><span style=display:flex><span>            x,
</span></span><span style=display:flex><span>            y,
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>Pixel::from_slice(
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>p.channels()
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .zip(q.channels().iter())
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>(c0, c1)<span style=color:#f92672>|</span> c0.checked_add(<span style=color:#f92672>*</span>c1).unwrap_or(<span style=color:#f92672>*</span>c0))
</span></span><span style=display:flex><span>                    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;&gt;</span>(),
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    imgbuf.save(<span style=color:#e6db74>&#34;flag.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=container></div></div><p>After saving this file, we place the images in the current directory. Let&rsquo;s
compile and run the program.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo run
</span></span></code></pre></div><p>Viewing &ldquo;flag.png&rdquo; shows us the flag in pixelated text.</p><p><img src=../../picoctf-cryptography-challenge-pixelated.png alt=flag.png></p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/cryptography class=list-tag>Cryptography</a>
<a href=https://lavafroth.is-a.dev/tags/ctf class=list-tag>CTF</a>
<a href=https://lavafroth.is-a.dev/tags/image-reconstruction class=list-tag>Image Reconstruction</a>
<a href=https://lavafroth.is-a.dev/tags/picoctf class=list-tag>PicoCTF</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/visual-cryptography class=list-tag>Visual Cryptography</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/kringlecon-2022-writeup/><span>←</span><span>Kringlecon 2022 Writeup</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/google-ctf-2022-treebox/><span>Treebox</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>