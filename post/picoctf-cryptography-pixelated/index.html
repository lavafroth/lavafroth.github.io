<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Pixelated - lavafroth</title><meta name=description content='This challenge gives use two images and asks us if we can make a flag out of them.
At first glance, both the images look like noise. Upon a quick web lookup of
visual cryptography, it appears
that these separate images, known as shares of the original image, can be overlayed
on each other to reconstruct the original image.
Exploration
Now, I&rsquo;m pretty sure that there are online services that will automatically solve these
but I decided to write some code to solve this locally. For the past week, I&rsquo;ve been
learning the Rust programming language and this was the perfect excuse to test my knowledge.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><noscript><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/noscript.min.css></noscript><link rel=prefetch as=font href=https://lavafroth.is-a.dev/LeagueGothic.ttf><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body class=not-ready data-menu=true><header class=header><div class=coalesce><h1><a class=site-name href=https://lavafroth.is-a.dev/>lavafroth</a></h1><svg class="btn-dark" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 60 60" preserveAspectRatio="xMinYMin meet"><path class="circle" d="M30 16c7.73.0 14 6.27 14 14 0 3.81-1.53 7.27-4 9.8-2.54 2.59-6.08 4.2-10 4.2-7.73.0-14-6.27-14-14 0-7.73 6.27-14 14-14z"/><g class="rays" data-svg-origin="30 30"><line class="line" x1="30" y1="11" x2="30" y2="7"/><line class="line" x1="43.44" y1="16.57" x2="46.26" y2="13.74"/><line class="line" x1="49" y1="30" x2="53" y2="30"/><line class="line" x1="43.43" y1="43.44" x2="46.26" y2="46.26"/><line class="line" x1="30" y1="49" x2="30" y2="53"/><line class="line" x1="16.56" y1="43.43" x2="13.74" y2="46.26"/><line class="line" x1="11" y1="30" x2="7" y2="30"/><line class="line" x1="16.57" y1="16.56" x2="13.74" y2="13.74"/></g></svg></div><nav class=social><a class=github style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a></nav><script>const bodyClx=document.body.classList,btnDark=document.querySelector(".btn-dark"),sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>(bodyClx.toggle("dark",e),localStorage.setItem("dark",e));setDark(darkVal?darkVal==="true":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",({matches:e})=>setDark(e))</script></header><main class=main><article class=post-single><header class=post-title><p><time>Nov 22, 2022 | 2 minutes read</time></p><h1 data-pagefind-meta=title>Pixelated</h1></header><section class=post-content data-pagefind-body><p>This challenge gives use two images and asks us if we can make a flag out of them.
At first glance, both the images look like noise. Upon a quick web lookup of
<a href=https://en.wikipedia.org/wiki/Visual_cryptography>visual cryptography</a>, it appears
that these separate images, known as shares of the original image, can be overlayed
on each other to reconstruct the original image.</p><h2 id=exploration>Exploration</h2><p>Now, I&rsquo;m pretty sure that there are online services that will automatically solve these
but I decided to write some code to solve this locally. For the past week, I&rsquo;ve been
learning the Rust programming language and this was the perfect excuse to test my knowledge.</p><p>First, we will create a cargo project. Let&rsquo;s call it &ldquo;solve&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo new solve
</span></span></code></pre></div><p>We&rsquo;ll then add the image library (crate) using cargo.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo add image
</span></span></code></pre></div><p>Now let&rsquo;s get some Rust in action. We&rsquo;ll start by editing the <code>src/main.rs</code> file.
First, we import the required types with the use statement.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>use</span> image::{GenericImageView, ImageBuffer, Pixel, RgbaImage};
</span></span></code></pre></div><p>We&rsquo;ll now write the main function. Let&rsquo;s open the images and store handles to them
in variables <code>a</code> and <code>b</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> image::open(<span style=color:#e6db74>&#34;scrambled1.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> image::open(<span style=color:#e6db74>&#34;scrambled2.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>For sanity check, let&rsquo;s make sure that the dimensions are the same for both the images.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>if</span> a.dimensions() <span style=color:#f92672>!=</span> b.dimensions() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Image dimensions don&#39;t match.&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Next, we&rsquo;ll create an image buffer for reconstructing the composite image.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> imgbuf: <span style=color:#a6e22e>RgbaImage</span> <span style=color:#f92672>=</span> ImageBuffer::new(a.width(), a.height());
</span></span></code></pre></div><p>Looping over the pixels in the shares,</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> ((x, y, p), (_, _, q)) <span style=color:#66d9ef>in</span> a.pixels().zip(b.pixels()) {
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>we sum the values in each channel &mldr;</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#f92672>&amp;</span>p.channels()
</span></span><span style=display:flex><span>    .iter()
</span></span><span style=display:flex><span>    .zip(q.channels().iter())
</span></span><span style=display:flex><span>    .map(<span style=color:#f92672>|</span>(c0, c1)<span style=color:#f92672>|</span> c0.checked_add(<span style=color:#f92672>*</span>c1).unwrap_or(<span style=color:#f92672>*</span>c0))
</span></span><span style=display:flex><span>    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;&gt;</span>(),
</span></span></code></pre></div><p>&mldr; and place the new pixel into the image buffer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>for</span> ((x, y, p), (_, _, q)) <span style=color:#66d9ef>in</span> a.pixels().zip(b.pixels()) {
</span></span><span style=display:flex><span>	imgbuf.put_pixel(x, y, <span style=color:#f92672>*</span>Pixel::from_slice(
</span></span><span style=display:flex><span>		<span style=color:#75715e>// --snip--
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    ),
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Finally, we save the image buffer into &ldquo;flag.png&rdquo;.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>imgbuf.save(<span style=color:#e6db74>&#34;flag.png&#34;</span>).unwrap();
</span></span></code></pre></div><p>The entire code looks like the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> a <span style=color:#f92672>=</span> image::open(<span style=color:#e6db74>&#34;scrambled1.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> b <span style=color:#f92672>=</span> image::open(<span style=color:#e6db74>&#34;scrambled2.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// the shares must have the same dimensions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> a.dimensions() <span style=color:#f92672>!=</span> b.dimensions() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>panic!</span>(<span style=color:#e6db74>&#34;Image dimensions don&#39;t match.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// create an empty buffer for the composite image
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> imgbuf: <span style=color:#a6e22e>RgbaImage</span> <span style=color:#f92672>=</span> ImageBuffer::new(a.width(), a.height());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ((x, y, p), (_, _, q)) <span style=color:#66d9ef>in</span> a.pixels().zip(b.pixels()) {
</span></span><span style=display:flex><span>        imgbuf.put_pixel(
</span></span><span style=display:flex><span>            x,
</span></span><span style=display:flex><span>            y,
</span></span><span style=display:flex><span>            <span style=color:#f92672>*</span>Pixel::from_slice(
</span></span><span style=display:flex><span>                <span style=color:#f92672>&amp;</span>p.channels()
</span></span><span style=display:flex><span>                    .iter()
</span></span><span style=display:flex><span>                    .zip(q.channels().iter())
</span></span><span style=display:flex><span>                    .map(<span style=color:#f92672>|</span>(c0, c1)<span style=color:#f92672>|</span> c0.checked_add(<span style=color:#f92672>*</span>c1).unwrap_or(<span style=color:#f92672>*</span>c0))
</span></span><span style=display:flex><span>                    .collect::<span style=color:#f92672>&lt;</span>Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;&gt;</span>(),
</span></span><span style=display:flex><span>            ),
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    imgbuf.save(<span style=color:#e6db74>&#34;flag.png&#34;</span>).unwrap();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>After saving this file, we place the images in the current directory. Let&rsquo;s
compile and run the program.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo run
</span></span></code></pre></div><p>Viewing &ldquo;flag.png&rdquo; shows us the flag in pixelated text.</p><p><img src=../../picoctf-cryptography-challenge-pixelated.png alt=flag.png></p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/cryptography class=list-tag>Cryptography</a>
<a href=https://lavafroth.is-a.dev/tags/ctf class=list-tag>CTF</a>
<a href=https://lavafroth.is-a.dev/tags/image-reconstruction class=list-tag>Image Reconstruction</a>
<a href=https://lavafroth.is-a.dev/tags/picoctf class=list-tag>PicoCTF</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/visual-cryptography class=list-tag>Visual Cryptography</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/kringlecon-2022-writeup/><span>←</span><span>Kringlecon 2022 Writeup</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/google-ctf-2022-treebox/><span>Treebox</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a> | <a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a> | <a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a> | <a href=https://lavafroth.is-a.dev/privacy>Privacy</a> | <a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>