<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Timing is Key: A Tale of Keystrokes and Timings - lavafroth</title><meta name=description content='Whether you&rsquo;re playing a video game or competing in a constrained attack-defense CTF, your keystroke timings matter.
We at waycrate value your precision, to the extent that you can configure your keybindings to perform actions either
on a key&rsquo;s press or a release.
Hi, my name&rsquo;s Himadri and this post is a part of a series explaining how
we (basically just me) are rewriting the config parser for swhkd using EBNF
grammar. I highly recommend reading the previous posts because I&rsquo;ll be referring
to them from time to time. In the last post, we talked about regular keys
that form the foundation of bindings. However, we glossed over the send and
on_release expressions in the code.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel="preload stylesheet" href=../../header.svg><noscript><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/noscript.min.css></noscript><link rel=preload as=font href=https://lavafroth.is-a.dev/LeagueGothic.ttf><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body class=not-ready data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/>lavafroth</a></h1><svg id="btnDark" class="btn-dark" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 60 60" preserveAspectRatio="xMinYMin meet"><path class="circle" d="M30 16c7.73.0 14 6.27 14 14 0 3.81-1.53 7.27-4 9.8-2.54 2.59-6.08 4.2-10 4.2-7.73.0-14-6.27-14-14 0-7.73 6.27-14 14-14z"/><g class="rays" data-svg-origin="30 30"><line class="line" x1="30" y1="11" x2="30" y2="7"/><line class="line" x1="43.44" y1="16.57" x2="46.26" y2="13.74"/><line class="line" x1="49" y1="30" x2="53" y2="30"/><line class="line" x1="43.43" y1="43.44" x2="46.26" y2="46.26"/><line class="line" x1="30" y1="49" x2="30" y2="53"/><line class="line" x1="16.56" y1="43.43" x2="13.74" y2="46.26"/><line class="line" x1="11" y1="30" x2="7" y2="30"/><line class="line" x1="16.57" y1="16.56" x2="13.74" y2="13.74"/></g></svg><div class=space></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><script>const bodyClx=document.body.classList,sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>(bodyClx.toggle("dark",e),localStorage.setItem("dark",e));setDark(darkVal?darkVal==="true":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",({matches:e})=>setDark(e))</script></header><main class=main><article class=post-single><header class=post-title><p><time>May 29, 2024 | 4 minutes read</time></p><h1 data-pagefind-meta=title>Timing is Key: A Tale of Keystrokes and Timings</h1></header><section class=post-content data-pagefind-body><p>Whether you&rsquo;re playing a video game or competing in a constrained attack-defense CTF, your keystroke timings matter.
We at waycrate value your precision, to the extent that you can configure your keybindings to perform actions either
on a key&rsquo;s press or a release.</p><p>Hi, my name&rsquo;s Himadri and this post is a part of a series explaining how
we (basically just me) are rewriting the config parser for swhkd using EBNF
grammar. I highly recommend reading the previous posts because I&rsquo;ll be referring
to them from time to time. In the last post, we talked about regular keys
that form the foundation of bindings. However, we glossed over the <code>send</code> and
<code>on_release</code> expressions in the code.</p><p>The <code>send</code> and <code>on_release</code> attributes are extensions that could be added to regular keys to be more specific about
the timing of an event. To make a binding respond to either key presses or releases, they are prefixed with the <code>~</code>
or the <code>@</code> characters respectively.</p><p><img src=../../swhkd-send-release.gif alt></p><p>For example, a bindings with that responds to <code>super</code> <code>a</code> can be made to respond specifically to the keypress instead
of the key release like the following:</p><pre tabindex=0><code>super + ~a
  notify-send &#39;hello&#39;
</code></pre><p>Now, to encode this as a formal grammar, we need to observe that these
attributes can be used both inside and outside shorthand contexts. This means,
the binding declarations <code>super + ~a</code> and <code>super + {@a, ~b}</code> are equally valid.</p><p>Intuitively, this begs the question of how keys like <code>~</code> or <code>@</code> could be specified literally.
The answer is similar to what we did for commas and dashes in shorthand contexts, we need
to escape the keys. The only difference this time is that the keys are escaped both inside
and outside shorthand contexts. In retrospective, the plus sign that has been serving as
the concatenator also needs to be escaped for literal representation.</p><p>To fix this, let&rsquo;s declare a convenience expression called <code>keys_always_escaped</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>keys_always_escaped <span style=color:#f92672>=</span> _{ <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>~&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>@&#34;</span> <span style=color:#f92672>|</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>+&#34;</span> }
</span></span></code></pre></div><p>This is how we will allow the user to literally mention a tilde or a plus.</p><p>Next, we modify the expression for a regular <code>key</code> to include these escaped literals besides the regular
ASCII alphanumeric characters.</p><p>We change the expression from</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>key <span style=color:#f92672>=</span> { <span style=color:#f92672>^</span><span style=color:#e6db74>&#34;enter&#34;</span> <span style=color:#f92672>|</span> <span style=color:#f92672>^</span><span style=color:#e6db74>&#34;return&#34;</span> <span style=color:#f92672>|</span> ASCII_ALPHANUMERIC }
</span></span></code></pre></div><p>to the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>key <span style=color:#f92672>=</span> { keys_always_escaped <span style=color:#f92672>|</span> <span style=color:#f92672>^</span><span style=color:#e6db74>&#34;enter&#34;</span> <span style=color:#f92672>|</span> <span style=color:#f92672>^</span><span style=color:#e6db74>&#34;return&#34;</span> <span style=color:#f92672>|</span> ASCII_ALPHANUMERIC }
</span></span></code></pre></div><p>Don&rsquo;t worry, we will add other symbols like semicolons, parentheses and the like to this expression
but we are starting off being a bit restrictive so that we can catch errors early.</p><p>We have to compensate for this change for the code side as well. This is the first time you&rsquo;ll see
real code from the project besides the formal grammar.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[derive(Debug, Clone)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Key</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> key: String,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> attribute: <span style=color:#a6e22e>KeyAttribute</span>,
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Notice how the <code>Key</code> variant has a field called <code>attribute</code> of type
<code>KeyAttribute</code>. This <code>KeyAttribute</code> is a bitflag represented by a
<code>u8</code> or a single byte. Why a single byte? Because it makes the underlying data
fairly inexpensive to copy. Although a boolean value should ideally be represented
by a single bit, most modern processor architectures use a single byte to represent them.
Bitflags can help us shave off the unused space.
We are using macros fromthe bitflag crate since Rust
does not natively have C-styled bitflags.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>bitflags::<span style=color:#a6e22e>bitflags!</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>KeyAttribute</span>: <span style=color:#66d9ef>u8</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> None <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000000</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> Send <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000001</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> OnRelease <span style=color:#f92672>=</span> <span style=color:#ae81ff>0b00000010</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> Both <span style=color:#f92672>=</span> Self::Send.bits() <span style=color:#f92672>|</span> Self::OnRelease.bits();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>According to the bitflag, the variant <code>None</code> is internally represented by a <code>0</code>,
<code>Send</code> is represented as a <code>1</code>, <code>OnRelease</code> as <code>2</code>, etc. Since all we care about
is whether an attribute is there or not, we can use a single bit as a bin for
each attribute. Any time we see one of the variants, we bitwise or the current
attribute set to flip the respective bit on.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>match</span> inner.as_rule() {
</span></span><span style=display:flex><span>    Rule::send <span style=color:#f92672>=&gt;</span> attribute <span style=color:#f92672>|=</span> KeyAttribute::Send,
</span></span><span style=display:flex><span>    Rule::on_release <span style=color:#f92672>=&gt;</span> attribute <span style=color:#f92672>|=</span> KeyAttribute::OnRelease,
</span></span><span style=display:flex><span>    Rule::key <span style=color:#f92672>=&gt;</span> key <span style=color:#f92672>=</span> pair_to_string(inner),
</span></span><span style=display:flex><span>    _ <span style=color:#f92672>=&gt;</span> {}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This saves us from writing cumbersome if statements that would have made more
sense if counting the occurrences was involved.</p><p>That&rsquo;s all for today, I hope you were impressed by the bitwise trick. In the
next post, I will talk about how I&rsquo;m implementing the grammar for modifier keys
and how they can be different from regular keys. See you soon!</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/edge-cases-you-shall-not-pass/><span>←</span><span>Edge cases? You Shall Not Pass!</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/keep-the-keys-clackin/><span>Keep the Keys Clackin'</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>