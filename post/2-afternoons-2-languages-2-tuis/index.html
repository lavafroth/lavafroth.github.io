<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>2 Afternoons, 2 Languages, 2 TUIs - lavafroth</title><meta name=description content='Yesterday I created a tool in Golang to help me render my animations a little
faster. Although the alterior reason was to check my Golang proficiency, today
I rewrote it in Rust and I was blown away by the differences in the final
products.
When I&rsquo;m rendering animations for a YouTube video, the general development
iteration comprises me creating or modifying a file, switching to a different
terminal pane and manually issuing a manim command for the respective file to
render and play the animation. My goal was to automate the last two processes,
switching terminal panes and manually issuing a command. The idea is to have a
tool running in the background that listens for filesystem events, like when a
file gets created or modified, and if the file happens to contain an animation,
renders it. On linux systems, it&rsquo;s mostly a bunch of bindings to inotify but I
have used platform agnostic libraries for both the languages.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><noscript><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/noscript.min.css></noscript><link rel=preload as=font href=https://lavafroth.is-a.dev/LeagueGothic.ttf><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body class=not-ready data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/>lavafroth</a></h1><svg id="btnDark" class="btn-dark" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 60 60" preserveAspectRatio="xMinYMin meet"><path class="circle" d="M30 16c7.73.0 14 6.27 14 14 0 3.81-1.53 7.27-4 9.8-2.54 2.59-6.08 4.2-10 4.2-7.73.0-14-6.27-14-14 0-7.73 6.27-14 14-14z"/><g class="rays" data-svg-origin="30 30"><line class="line" x1="30" y1="11" x2="30" y2="7"/><line class="line" x1="43.44" y1="16.57" x2="46.26" y2="13.74"/><line class="line" x1="49" y1="30" x2="53" y2="30"/><line class="line" x1="43.43" y1="43.44" x2="46.26" y2="46.26"/><line class="line" x1="30" y1="49" x2="30" y2="53"/><line class="line" x1="16.56" y1="43.43" x2="13.74" y2="46.26"/><line class="line" x1="11" y1="30" x2="7" y2="30"/><line class="line" x1="16.57" y1="16.56" x2="13.74" y2="13.74"/></g></svg><div class=push></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><script>const bodyClx=document.body.classList,sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>(bodyClx.toggle("dark",e),localStorage.setItem("dark",e));setDark(darkVal?darkVal==="true":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",({matches:e})=>setDark(e))</script></header><main class=main><article class=post-single><header class=post-title><p><time>May 23, 2024 | 5 minutes read</time></p><h1 data-pagefind-meta=title>2 Afternoons, 2 Languages, 2 TUIs</h1></header><section class=post-content data-pagefind-body><p>Yesterday I created a tool in Golang to help me render my animations a little
faster. Although the alterior reason was to check my Golang proficiency, today
I rewrote it in Rust and I was blown away by the differences in the final
products.</p><p>When I&rsquo;m rendering animations for a YouTube video, the general development
iteration comprises me creating or modifying a file, switching to a different
terminal pane and manually issuing a <em>manim</em> command for the respective file to
render and play the animation. My goal was to automate the last two processes,
switching terminal panes and manually issuing a command. The idea is to have a
tool running in the background that listens for filesystem events, like when a
file gets created or modified, and if the file happens to contain an animation,
renders it. On linux systems, it&rsquo;s mostly a bunch of bindings to <code>inotify</code> but I
have used platform agnostic libraries for both the languages.</p><p>There are also a few knobs that can be turned when it comes to rendering these
animations. Arguably the most important one among them is the quality parameter.
A bulk of my development cycles are spent rendering animations at a low quality
and previewing them for feedback. Once I&rsquo;m satisfied with the animation, I tend
to create a high quality render for sanity checks as well as for placing them on
the final project timeline.</p><p>Since I&rsquo;m working solo for now without editors and peer animators, there&rsquo;s
no race condition as to which animation gets rendered first it two files are
modified at the same time.</p><p>The Go version took me around 6 hours to finish. The Rust version fared at
a maximum of 4 hours. The Go tool should have taken less time compared to
the Rust tool because I used the <a href=https://charm.sh>CharmBracelet</a> stack
including <a href=https://github.com/charmbracelet/bubbletea>BubbleTea</a>, [Bubbles]
(<a href=https://github.com/charmbracelet/bubbles>https://github.com/charmbracelet/bubbles</a>) and <a href=https://github.com/charmbracelet/lipgloss>LipGloss</a>.
For those who are unaware, <em>BubbleTea</em> uses the Elm
architecture for rendering and I have already worked on a GUI project that
employs the Elm architecture.</p><p>For the Rust side, I went with <a href=https://github.com/ratatui-org/ratatui>ratatui</a>
with a few libraries like <a href=https://github.com/a-kenji/tui-term>tui-term</a> and <a href=https://github.com/tatounee/ratatui-explorer>tui-explorer</a> for scaffolding.
<em>tui-term</em> enabled me to easily spawn a pseudo terminal session in a pane
inside the current program and <em>ratatui-explorer</em> was useful for a quick and easy
file explorer.</p><p>The Go version had pretty things like modals and popups akin to a GUI application. In some sense, it felt more beginner friendly.</p><p><img src=../../222go-preview.gif alt="The go version"></p><p>I had this strikingly different mindset when I was developing the Rust version. Knowing that my hands are chained to the keyboard and that I don&rsquo;t need a mouse,
I designed the Rust version to be more keyboard centric. Using the <code>tab</code> or arrow keys to move around? No thank you, <code>hjkl</code> is fine by me.</p><p><img src=../../222-project-directory.gif alt="Rust file picker"></p><p>Focus on buttons and then hit enter to perform actions? Nah, key chords are faster. For this version, I chose the minimalist route, taking subtle inspirations from helix.</p><p>Helix has a feature akin to the <code>whichkey</code> plugin for <code>neovim</code> where if you press a key like <code>g</code> and wait, it shows you what keys to press next for related actions.
For the <code>g</code> example, it would say that you can press <code>g</code> again to go to the file&rsquo;s start, <code>e</code> to go the file&rsquo;s end and so on.</p><p><img src=../../222-re-render.gif alt="Triggering a re-render in the Rust version"></p><p>The Rust tool has a single pane at the center which displays the output of <em>manim</em> commands that get executed. A to status line describes the current working directory and the current render quality.
Lastly, there&rsquo;s a bottom legend that tells you what key chord you can chain next for a particular action. For example, you start a key chord by pressing <code>space</code>,
then you can press <code>q</code> to enter the context of setting the render quality. Finally you can press keys like <code>l</code> for 480p, <code>m</code> for <code>720p</code>, <code>h</code> for 1080p and so on.</p><p><img src=../../222-changing-quality.gif alt="Triggering a re-render in the Rust version"></p><p>The last point in favor of the second architecture is how the key chords solidify in my spinal memory. After using it for just a few minutes,
I&rsquo;m already incredibly (blazingly) fast at it. Compare that to the more polished design of the first, where using <code>tab</code>s and arrow keys always feels hit or miss.</p><p>It&rsquo;s incredibly fascinating how a change in the language made a perceptible
difference in the architecture of the final products. However, I don&rsquo;t think
this is necessarily a fault of <em>BubbleTea</em> or any of the other <em>CharmBracelet</em>
products. Rather, it&rsquo;s a fault in my perception of the languages. I&rsquo;ve always
thought of Go as a loosey-goosey language due to its Pythonic outlook with
less magic. When I&rsquo;m building a Golang tool, it feels like I&rsquo;m making a paper
plane whereas building a Rust tool feels like using magnalum to build an actual
airplane.</p><p>With that said, if you&rsquo;re a beginner and <code>Arc&lt;RwLock&lt;T>></code> gave you a jumpscare,
it might be worth sticking with Golang <em>CharmBracelet</em> stack, it&rsquo;s simple and
can take you pretty far. If you&rsquo;re good with Rust, don&rsquo;t sleep on <em>ratatui</em>.
It&rsquo;s way better than how I remember it from a couple years ago. If you&rsquo;re
interested in the code, check out the Go project <abbr title="repository is no longer public">here</abbr>
and the Rust project <a href=https://github.com/lavafroth/hm>here</a>.</p><p>Until next time, remember, Rust is 2 fast 2 furious.</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/go class=list-tag>Go</a>
<a href=https://lavafroth.is-a.dev/tags/terminal class=list-tag>Terminal</a>
<a href=https://lavafroth.is-a.dev/tags/ui class=list-tag>UI</a>
<a href=https://lavafroth.is-a.dev/tags/youtube class=list-tag>YouTube</a>
<a href=https://lavafroth.is-a.dev/tags/animation class=list-tag>Animation</a>
<a href=https://lavafroth.is-a.dev/tags/manim class=list-tag>Manim</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/keep-the-keys-clackin/><span>←</span><span>Keep the Keys Clackin'</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/><span>A SWEET Little Parser</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>