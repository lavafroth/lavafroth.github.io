<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>2 Afternoons, 2 Languages, 2 TUIs - lavafroth</title><meta name=description content='Yesterday I created a tool in Golang to help me render my animations a little
faster. Although the alterior reason was to check my Golang proficiency, today
I rewrote it in Rust and I was blown away by the differences in the final
products.
When I&rsquo;m rendering animations for a YouTube video, the general development
iteration comprises me creating or modifying a file, switching to a different
terminal pane and manually issuing a manim command for the respective file to
render and play the animation. My goal was to automate the last two processes,
switching terminal panes and manually issuing a command. The idea is to have a
tool running in the background that listens for filesystem events, like when a
file gets created or modified, and if the file happens to contain an animation,
renders it. On linux systems, it&rsquo;s mostly a bunch of bindings to inotify but I
have used platform agnostic libraries for both the languages.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2400"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a></h1><div class=push></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a></header><main class=main><article class=post-single><header class=post-title><p><time>May 23, 2024 | 5 minutes read</time></p><h1 data-pagefind-meta=title>2 Afternoons, 2 Languages, 2 TUIs</h1></header><section class=post-content data-pagefind-body><p>Yesterday I created a tool in Golang to help me render my animations a little
faster. Although the alterior reason was to check my Golang proficiency, today
I rewrote it in Rust and I was blown away by the differences in the final
products.</p><p>When I&rsquo;m rendering animations for a YouTube video, the general development
iteration comprises me creating or modifying a file, switching to a different
terminal pane and manually issuing a <em>manim</em> command for the respective file to
render and play the animation. My goal was to automate the last two processes,
switching terminal panes and manually issuing a command. The idea is to have a
tool running in the background that listens for filesystem events, like when a
file gets created or modified, and if the file happens to contain an animation,
renders it. On linux systems, it&rsquo;s mostly a bunch of bindings to <code>inotify</code> but I
have used platform agnostic libraries for both the languages.</p><p>There are also a few knobs that can be turned when it comes to rendering these
animations. Arguably the most important one among them is the quality parameter.
A bulk of my development cycles are spent rendering animations at a low quality
and previewing them for feedback. Once I&rsquo;m satisfied with the animation, I tend
to create a high quality render for sanity checks as well as for placing them on
the final project timeline.</p><p>Since I&rsquo;m working solo for now without editors and peer animators, there&rsquo;s
no race condition as to which animation gets rendered first it two files are
modified at the same time.</p><p>The Go version took me around 6 hours to finish. The Rust version fared at
a maximum of 4 hours. The Go tool should have taken less time compared to
the Rust tool because I used the <a href=https://charm.sh>CharmBracelet</a> stack
including <a href=https://github.com/charmbracelet/bubbletea>BubbleTea</a>, [Bubbles]
(<a href=https://github.com/charmbracelet/bubbles>https://github.com/charmbracelet/bubbles</a>) and <a href=https://github.com/charmbracelet/lipgloss>LipGloss</a>.
For those who are unaware, <em>BubbleTea</em> uses the Elm
architecture for rendering and I have already worked on a GUI project that
employs the Elm architecture.</p><p>For the Rust side, I went with <a href=https://github.com/ratatui-org/ratatui>ratatui</a>
with a few libraries like <a href=https://github.com/a-kenji/tui-term>tui-term</a> and <a href=https://github.com/tatounee/ratatui-explorer>tui-explorer</a> for scaffolding.
<em>tui-term</em> enabled me to easily spawn a pseudo terminal session in a pane
inside the current program and <em>ratatui-explorer</em> was useful for a quick and easy
file explorer.</p><p>The Go version had pretty things like modals and popups akin to a GUI application. In some sense, it felt more beginner friendly.</p><p><img src=../../222go-preview.gif alt="The go version"></p><p>I had this strikingly different mindset when I was developing the Rust version. Knowing that my hands are chained to the keyboard and that I don&rsquo;t need a mouse,
I designed the Rust version to be more keyboard centric. Using the <code>tab</code> or arrow keys to move around? No thank you, <code>hjkl</code> is fine by me.</p><p><img src=../../222-project-directory.gif alt="Rust file picker"></p><p>Focus on buttons and then hit enter to perform actions? Nah, key chords are faster. For this version, I chose the minimalist route, taking subtle inspirations from helix.</p><p>Helix has a feature akin to the <code>whichkey</code> plugin for <code>neovim</code> where if you press a key like <code>g</code> and wait, it shows you what keys to press next for related actions.
For the <code>g</code> example, it would say that you can press <code>g</code> again to go to the file&rsquo;s start, <code>e</code> to go the file&rsquo;s end and so on.</p><p><img src=../../222-re-render.gif alt="Triggering a re-render in the Rust version"></p><p>The Rust tool has a single pane at the center which displays the output of <em>manim</em> commands that get executed. A to status line describes the current working directory and the current render quality.
Lastly, there&rsquo;s a bottom legend that tells you what key chord you can chain next for a particular action. For example, you start a key chord by pressing <code>space</code>,
then you can press <code>q</code> to enter the context of setting the render quality. Finally you can press keys like <code>l</code> for 480p, <code>m</code> for <code>720p</code>, <code>h</code> for 1080p and so on.</p><p><img src=../../222-changing-quality.gif alt="Triggering a re-render in the Rust version"></p><p>The last point in favor of the second architecture is how the key chords solidify in my spinal memory. After using it for just a few minutes,
I&rsquo;m already incredibly (blazingly) fast at it. Compare that to the more polished design of the first, where using <code>tab</code>s and arrow keys always feels hit or miss.</p><p>It&rsquo;s incredibly fascinating how a change in the language made a perceptible
difference in the architecture of the final products. However, I don&rsquo;t think
this is necessarily a fault of <em>BubbleTea</em> or any of the other <em>CharmBracelet</em>
products. Rather, it&rsquo;s a fault in my perception of the languages. I&rsquo;ve always
thought of Go as a loosey-goosey language due to its Pythonic outlook with
less magic. When I&rsquo;m building a Golang tool, it feels like I&rsquo;m making a paper
plane whereas building a Rust tool feels like using magnalum to build an actual
airplane.</p><p>With that said, if you&rsquo;re a beginner and <code>Arc&lt;RwLock&lt;T>></code> gave you a jumpscare,
it might be worth sticking with Golang <em>CharmBracelet</em> stack, it&rsquo;s simple and
can take you pretty far. If you&rsquo;re good with Rust, don&rsquo;t sleep on <em>ratatui</em>.
It&rsquo;s way better than how I remember it from a couple years ago. If you&rsquo;re
interested in the code, check out the Go project <abbr title="repository is no longer public">here</abbr>
and the Rust project <a href=https://github.com/lavafroth/hm>here</a>.</p><p>Until next time, remember, Rust is 2 fast 2 furious.</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/go class=list-tag>Go</a>
<a href=https://lavafroth.is-a.dev/tags/terminal class=list-tag>Terminal</a>
<a href=https://lavafroth.is-a.dev/tags/ui class=list-tag>UI</a>
<a href=https://lavafroth.is-a.dev/tags/youtube class=list-tag>YouTube</a>
<a href=https://lavafroth.is-a.dev/tags/animation class=list-tag>Animation</a>
<a href=https://lavafroth.is-a.dev/tags/manim class=list-tag>Manim</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/keep-the-keys-clackin/><span>←</span><span>Keep the Keys Clackin'</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/a-sweet-little-config-parser/><span>A SWEET Little Parser</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>