<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Compact XOR - lavafroth</title><meta name=description content='Description
I found some hex in a file called fleg, but I’m not sure how it’s encoded. I’m pretty sure it’s some kind of xor…
Exploration
We begin by creating a new rust project.
cargo new amateurs
cd amateurs
cargo add hex
cargo add itertools
Let&rsquo;s decode the hexadecimal contents of the file using the following Rust code:
fn main() -> Result<(), Box<dyn std::error::Error>> {
    let bytes = hex::decode("610c6115651072014317463d73127613732c73036102653a6217742b701c61086e1a651d742b69075f2f6c0d69075f2c690e681c5f673604650364023944")?;
    let stream = String::from_utf8_lossy(&amp;bytes);
    println!("{:?}", stream);
    Ok(())
}
To execute the code, issue the following.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/rss.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body><header><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2400"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a><nav><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><a href=../../index.xml aria-label=rss style=--url:url(./rss.svg)></a><nav></header><main><article class=post-single data-pagefind-body><hgroup><p data-pagefind-ignore><time>Aug 24, 2023 | 2 minutes read</time></p><h1 data-pagefind-meta=title>Compact XOR</h1></hgroup><section class=post-content><h1 id=description>Description</h1><p>I found some hex in a file called fleg, but I’m not sure how it’s encoded. I’m pretty sure it’s some kind of xor…</p><h1 id=exploration>Exploration</h1><p>We begin by creating a new rust project.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo new amateurs
</span></span><span style=display:flex><span>cd amateurs
</span></span><span style=display:flex><span>cargo add hex
</span></span><span style=display:flex><span>cargo add itertools
</span></span></code></pre></div><p>Let&rsquo;s decode the hexadecimal contents of the file using the following Rust code:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> std::error::Error<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> bytes <span style=color:#f92672>=</span> hex::decode(<span style=color:#e6db74>&#34;610c6115651072014317463d73127613732c73036102653a6217742b701c61086e1a651d742b69075f2f6c0d69075f2c690e681c5f673604650364023944&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stream <span style=color:#f92672>=</span> String::from_utf8_lossy(<span style=color:#f92672>&amp;</span>bytes);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, stream);
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To execute the code, issue the following.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>cargo run
</span></span></code></pre></div><p>This gives us a string with every other character being non-printable.</p><pre tabindex=0><code>&#34;a\u{c}a\u{15}e\u{10}r\u{1}C\u{17}F=s\u{12}v\u{13}s,s\u{3}a\u{2}e:b\u{17}t+p\u{1c}a\u{8}n\u{1a}e\u{1d}t+i\u{7}_/l\ri\u{7}_,i\u{e}h\u{1c}_g6\u{4}e\u{3}d\u{2}9D&#34;
</code></pre><p>Notice how each odd numbered character spells out the corresponding character for an &ldquo;amateursCTF{&mldr;}&rdquo; flag.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> odd_bytes <span style=color:#f92672>=</span> bytes.iter().step_by(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> odd_bytes_vec: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> odd_bytes.clone().copied().collect();
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> odd_characters <span style=color:#f92672>=</span> String::from_utf8_lossy(<span style=color:#f92672>&amp;</span>odd_bytes_vec);
</span></span><span style=display:flex><span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, odd_characters);
</span></span></code></pre></div><p>This code gives us the following result:</p><pre tabindex=0><code>&#34;aaerCFsvssaebtpaneti_li_ih_6ed9&#34;
</code></pre><p>On further inspection, it appears that the first character of the raw bytes, &lsquo;a&rsquo;, <strong>xor</strong>ed with the second byte, 0xC results in the character &rsquo;m&rsquo;.
After this transformation, the first 3 bytes spell &ldquo;ama&rdquo; like the start of an &ldquo;amateursCTF{&mldr;}&rdquo; flag.</p><p>The above observation implies that every other character is the <strong>xor</strong> of its previous character and its original counterpart. Since <strong>xor</strong> is an involuntary function,
we can now reverse this transformation by <strong>xor</strong>ing them back with their previous characters.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> even_bytes <span style=color:#f92672>=</span> bytes.iter().skip(<span style=color:#ae81ff>1</span>).step_by(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> recovered <span style=color:#f92672>=</span> odd_bytes.clone().zip(even_bytes).map(<span style=color:#f92672>|</span>(a, b)<span style=color:#f92672>|</span> a <span style=color:#f92672>^</span> b);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> solution: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> itertools::interleave(odd_bytes.copied(), recovered).collect();
</span></span><span style=display:flex><span><span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, String::from_utf8_lossy(<span style=color:#f92672>&amp;</span>solution));
</span></span></code></pre></div><p>The final code looks like the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>main</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), Box<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>dyn</span> std::error::Error<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> bytes <span style=color:#f92672>=</span> hex::decode(<span style=color:#e6db74>&#34;610c6115651072014317463d73127613732c73036102653a6217742b701c61086e1a651d742b69075f2f6c0d69075f2c690e681c5f673604650364023944&#34;</span>)<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> stream <span style=color:#f92672>=</span> String::from_utf8_lossy(<span style=color:#f92672>&amp;</span>bytes);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, stream);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> odd_bytes <span style=color:#f92672>=</span> bytes.iter().step_by(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> odd_bytes_vec: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> odd_bytes.clone().copied().collect();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> odd_characters <span style=color:#f92672>=</span> String::from_utf8_lossy(<span style=color:#f92672>&amp;</span>odd_bytes_vec);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{:?}</span><span style=color:#e6db74>&#34;</span>, odd_characters);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> even_bytes <span style=color:#f92672>=</span> bytes.iter().skip(<span style=color:#ae81ff>1</span>).step_by(<span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> recovered <span style=color:#f92672>=</span> odd_bytes.clone().zip(even_bytes).map(<span style=color:#f92672>|</span>(a, b)<span style=color:#f92672>|</span> a <span style=color:#f92672>^</span> b);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> solution: Vec<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>u8</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>=</span> itertools::interleave(odd_bytes.copied(), recovered).collect();
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>println!</span>(<span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#34;</span>, String::from_utf8_lossy(<span style=color:#f92672>&amp;</span>solution));
</span></span><span style=display:flex><span>    Ok(())
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Running this code gives us the flag.</p><pre tabindex=0><code>amateursCTF{saves_space_but_plaintext_in_plain_sight_862efdf9}
</code></pre></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/amateursctf class=list-tag>AmateursCTF</a>
<a href=https://lavafroth.is-a.dev/tags/ctf class=list-tag>CTF</a>
<a href=https://lavafroth.is-a.dev/tags/cryptography class=list-tag>Cryptography</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/headache-reverse-engineering-amateursctf-2023/><span>←</span><span>Headache</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/volcano-reverse-engineering-amateursctf-2023/><span>Volcano</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>