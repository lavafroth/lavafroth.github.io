<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>Test Driven Development - The Pinnacle of Engineering - lavafroth</title><meta name=description content='Hello and welcome to the seventh instalment in the series where we build a
parser for a domain specific language in Rust. I would highly recommend you to
go through the previous articles to make sense of what we’ll talk about today.
Tying loose ends
Up until the last post, we had covered quite some ground, from building
elementary expressions to the penultimate levels of abstraction for macroscopic
expressions.
Let&rsquo;s begin today&rsquo;s conversation by finishing off where we left off. For us to
be able to parse an entire config file, we must have one main rule. We combine
all of the primitives that we have built so far: comments, modes, bindings,
unbinds and imports into a blanket content expression.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel="preload stylesheet" href=../../header.svg><noscript><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/noscript.min.css></noscript><link rel=preload as=font href=https://lavafroth.is-a.dev/LeagueGothic.ttf><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body class=not-ready data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/>lavafroth</a></h1><svg id="btnDark" class="btn-dark" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 60 60" preserveAspectRatio="xMinYMin meet"><path class="circle" d="M30 16c7.73.0 14 6.27 14 14 0 3.81-1.53 7.27-4 9.8-2.54 2.59-6.08 4.2-10 4.2-7.73.0-14-6.27-14-14 0-7.73 6.27-14 14-14z"/><g class="rays" data-svg-origin="30 30"><line class="line" x1="30" y1="11" x2="30" y2="7"/><line class="line" x1="43.44" y1="16.57" x2="46.26" y2="13.74"/><line class="line" x1="49" y1="30" x2="53" y2="30"/><line class="line" x1="43.43" y1="43.44" x2="46.26" y2="46.26"/><line class="line" x1="30" y1="49" x2="30" y2="53"/><line class="line" x1="16.56" y1="43.43" x2="13.74" y2="46.26"/><line class="line" x1="11" y1="30" x2="7" y2="30"/><line class="line" x1="16.57" y1="16.56" x2="13.74" y2="13.74"/></g></svg><div class=space></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a><script>const bodyClx=document.body.classList,sysDark=window.matchMedia("(prefers-color-scheme: dark)"),darkVal=localStorage.getItem("dark"),setDark=e=>(bodyClx.toggle("dark",e),localStorage.setItem("dark",e));setDark(darkVal?darkVal==="true":sysDark.matches),requestAnimationFrame(()=>bodyClx.remove("not-ready")),btnDark.addEventListener("click",()=>setDark(!bodyClx.contains("dark"))),sysDark.addEventListener("change",({matches:e})=>setDark(e))</script></header><main class=main><article class=post-single><header class=post-title><p><time>Jun 24, 2024 | 4 minutes read</time></p><h1 data-pagefind-meta=title>Test Driven Development - The Pinnacle of Engineering</h1></header><section class=post-content data-pagefind-body><p>Hello and welcome to the seventh instalment in the series where we build a
parser for a domain specific language in Rust. I would highly recommend you to
go through the previous articles to make sense of what we’ll talk about today.</p><h2 id=tying-loose-ends>Tying loose ends</h2><p>Up until the last post, we had covered quite some ground, from building
elementary expressions to the penultimate levels of abstraction for macroscopic
expressions.</p><p>Let&rsquo;s begin today&rsquo;s conversation by finishing off where we left off. For us to
be able to parse an entire config file, we must have one main rule. We combine
all of the primitives that we have built so far: comments, modes, bindings,
unbinds and imports into a blanket content expression.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ebnf data-lang=ebnf><span style=display:flex><span><span style=color:#66d9ef>content </span><span style=color:#f92672>=</span> <span style=color:#960050;background-color:#1e0010>_</span>{ <span style=color:#66d9ef>comment </span>| <span style=color:#66d9ef>mode </span>| <span style=color:#66d9ef>unbind </span>| <span style=color:#66d9ef>binding </span>| <span style=color:#66d9ef>import </span>| <span style=color:#66d9ef>NEWLINE </span>}
</span></span></code></pre></div><p>Obviously, a configuration file in the wild might very well have more than
one of the aforementioned primitives. Thus, to top it all off, we build a
final <code>main</code> expression that we subsequently use in the code side to match the
contents of a file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ebnf data-lang=ebnf><span style=display:flex><span><span style=color:#66d9ef>main </span><span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>SOI </span><span style=color:#960050;background-color:#1e0010>~</span> <span style=color:#66d9ef>content</span><span style=color:#960050;background-color:#1e0010>*</span> <span style=color:#960050;background-color:#1e0010>~</span> <span style=color:#66d9ef>EOI</span>
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>The expression starts with a <code>SOI</code> or a <em>start of identifier</em> which is a fancy
way of saying start of a file in <a href=https://pest.rs>pest</a>. It may contain zero or
more of the blanket <code>content</code> expressions that we defined a while ago. Finally,
we have to mark it with an <code>EOI</code>, which stands for <em>end of identifier</em>.</p><h2 id=writing-tests>Writing tests</h2><p>Writing tests for this parser proved to be a relatively straightforward task,
as many of them were already available from the previous version of the parser.
This allowed us to both port the basic tests as well as build upon existing test cases
that specifically targeted the changes made in this iteration.</p><p>The original crate made use of <code>std::io::Result</code> instead of defining its own error type
and while offloading the errors to an already available type might sound like less work,
it often meant that the grammar related errors had to be unwraps, panics, asserts or in
the worst case, just unrelated to <code>io::Result</code> itself.</p><p>Tell me, how does a missing identifier error make sense as an <code>io::Error</code>? It doesn&rsquo;t,
that&rsquo;s why we are using the standard <code>Result</code> type with the error generic type to be
our custom error type.</p><p>Thus, the tests we&rsquo;re writing have the general signature like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[test]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>test_multiple_keybinds</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), ParseError<span style=color:#f92672>&gt;</span> { <span style=color:#75715e>/* ... */</span> }
</span></span></code></pre></div><p>A significant portion of these tests involved asserting that keybinds in the
config files matched their internal representations. We do this by defining
a known representation (starting off with a close enough guess) and asserting
whether it matches what has been parsed.</p><p>Consider the <code>test_command_with_many_spaces</code> test: we define the raw contents
and let the parser ingest it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> contents <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;
</span></span></span><span style=display:flex><span><span style=color:#e6db74>p
</span></span></span><span style=display:flex><span><span style=color:#e6db74>    xbacklight -inc 10 -fps 30 -time 200
</span></span></span><span style=display:flex><span><span style=color:#e6db74>        &#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> parsed <span style=color:#f92672>=</span> SwhkdParser::from(<span style=color:#f92672>&amp;</span>contents)<span style=color:#f92672>?</span>;
</span></span></code></pre></div><p>Following this, we define what we know is going to be the internal representation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>let</span> known <span style=color:#f92672>=</span> <span style=color:#a6e22e>vec!</span>[Binding {
</span></span><span style=display:flex><span>    definition: <span style=color:#a6e22e>Definition</span> {
</span></span><span style=display:flex><span>        modifiers: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[],
</span></span><span style=display:flex><span>        key: <span style=color:#a6e22e>Key</span>::new(<span style=color:#e6db74>&#34;p&#34;</span>, KeyAttribute::None),
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>    command: String::from(<span style=color:#e6db74>&#34;xbacklight -inc 10 -fps 30 -time 200&#34;</span>),
</span></span><span style=display:flex><span>}];
</span></span></code></pre></div><p>Finally, we assert whether these two bindings actually match.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#a6e22e>assert_eq!</span>(parsed.bindings, known);
</span></span></code></pre></div><p>Furthermore, some error tests became trivially easy thanks to the pest crate&rsquo;s
ability to generate meaningful errors. All we had to do was assert whether a
given result was an error or not, which greatly simplified the testing process.</p><p>Consider the following test where we simply use the <code>is_err</code> method to check for errors.</p><pre tabindex=0><code>#[test]
fn test_invalid_keybinding() {
    let contents = &#34;
p
    xbacklight -inc 10 -fps 30 -time 200

pesto
    xterm
                    &#34;;

    assert!(SwhkdParser::from(&amp;contents).is_err());
}
</code></pre><p>In the future, we can take advantage of the extensibility and check for line and column
numbers to be extra precise.</p><p>While porting the tests, I also came across a bug where using a single letter for a binding
would be ignored. Turns out that a multi cartesian product of a vector of vectors
(all the modifier variant groups) works fine with a vector of keys except when all
modifier groups are empty. In such a case, the multi cartesian product has no output.</p><p>Mathematically, the cartesian product of {phi, phi, &mldr;, phi} is phi but the cartesian product of
{} yields no value at all. Thus, we had to create a small check as a fix before blinding computing the cartesian products.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>compile</span>(self) -&gt; Vec<span style=color:#f92672>&lt;</span>Definition<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> self.modifiers.is_empty() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> self
</span></span><span style=display:flex><span>            .keys
</span></span><span style=display:flex><span>            .into_iter()
</span></span><span style=display:flex><span>            .map(<span style=color:#f92672>|</span>key<span style=color:#f92672>|</span> Definition {
</span></span><span style=display:flex><span>                modifiers: <span style=color:#a6e22e>vec</span><span style=color:#f92672>!</span>[],
</span></span><span style=display:flex><span>                key,
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>            .collect();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    self.modifiers
</span></span><span style=display:flex><span>        .into_iter()
</span></span><span style=display:flex><span>        .multi_cartesian_product()
</span></span><span style=display:flex><span>        .cartesian_product(self.keys)
</span></span><span style=display:flex><span>        .map(<span style=color:#f92672>|</span>(modifiers, key)<span style=color:#f92672>|</span> Definition { modifiers, key })
</span></span><span style=display:flex><span>        .collect()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Here, in the case where there are no modifiers variant groups, we instead anchor on the keys and
generate the definitions.</p><p>Okay. I know that was a long read. It took me quite some time to write this too but hopefully, you
can learn from my mistakes and embrace testing slightly ahead of time. See you soon.</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/ebnf class=list-tag>EBNF</a>
<a href=https://lavafroth.is-a.dev/tags/google-summer-of-code class=list-tag>Google Summer of Code</a>
<a href=https://lavafroth.is-a.dev/tags/rust class=list-tag>Rust</a>
<a href=https://lavafroth.is-a.dev/tags/swhkd class=list-tag>SWHKD</a>
<a href=https://lavafroth.is-a.dev/tags/waycrate class=list-tag>Waycrate</a>
<a href=https://lavafroth.is-a.dev/tags/wayland class=list-tag>Wayland</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/preventing-infinite-recursions-from-eating-your-lunch/><span>←</span><span>Preventing Infinite Recursions From Eating Your Lunch</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/modes-unbinds-and-other-ensembled-parser-patterns/><span>Modes, Unbinds and Other Ensembled Parser Patterns</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>