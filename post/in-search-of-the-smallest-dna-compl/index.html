<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>In search of the smallest DNA complement function - lavafroth</title><meta name=description content='For the past few weeks, I have been trying to come up with a fast and purely agebraic function to convert DNA bases to their
respective complements.
Problem statement
Our goal is rather straightforward. We aim to create a mapping of the characters a, t, g, c and n to their respective complements.
We choose to keep our solution one step behind the classical reverse complement which reverses the string after the mapping.'><meta name=author content><link rel="preload stylesheet" as=style href=https://lavafroth.is-a.dev/app.min.css><link rel=preload as=image href=../../header.svg><link as=font href=https://lavafroth.is-a.dev/latinmodern-math.otf><link rel=preload as=image href=https://lavafroth.is-a.dev/github.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/about.svg><link rel=preload as=image href=https://lavafroth.is-a.dev/art.svg><link rel=icon href=https://lavafroth.is-a.dev/favicon.png><link rel=blog-icon href=https://lavafroth.is-a.dev/icon.png></head><body data-menu=true><header class=header><h1><a class=site-name href=https://lavafroth.is-a.dev/><svg viewBox="0 0 8790 2400"><path d="M80 1935V465h216v1270h286v2e2zm853 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm1025 528L2014 465h210l108 868 8 142h12l8-142 108-868h210l-224 1470zm813 0 222-1470h264l222 1470h-210l-40-3e2h-208l-40 3e2zm280-528h148l-62-494-6-78h-12l-6 78zm851 528V465h514v222h-298v386h2e2v222h-2e2v640zm910 0V465h216q194 0 286 108 92 107 92 316 0 124-43 215-44 90-106 132l147 699h-216l-122-620h-38v620zm216-820q60 0 95-26 35-27 50-76t15-116q0-105-34-161-35-57-126-57zm1084 836q-90 0-154-42-65-42-99-114-35-72-35-162V767q0-91 35-162 34-72 99-114 64-42 154-42t155 42q64 42 99 114 34 72 34 162v866q0 90-34 162-35 72-99 114-65 42-155 42zm0-210q40 0 56-33 16-34 16-75V767q0-41-17-74-17-34-55-34-37 0-54 34-18 33-18 74v866q0 41 17 75 17 33 55 33zm890 194V687h-204V465h624v222h-204v1248zm828 0V465h216v608h168V465h216v1470h-216v-640h-168v640z"/></svg></a></h1><div class=push></div><a style=--url:url(./github.svg) href=https://github.com/lavafroth aria-label=github target=_blank></a><a href=../../about/ aria-label=about style=--url:url(./about.svg)></a><a href=../../art/ aria-label=art style=--url:url(./art.svg)></a></header><main class=main><article class=post-single data-pagefind-body><header class=post-title><p data-pagefind-ignore><time>Feb 14, 2025 | 6 minutes read</time></p><h1 data-pagefind-meta=title>In search of the smallest DNA complement function</h1></header><section class=post-content><p>For the past few weeks, I have been trying to come up with a fast and purely agebraic function to convert DNA bases to their
respective complements.</p><h2 id=problem-statement>Problem statement</h2><p>Our goal is rather straightforward. We aim to create a mapping of the characters <code>a</code>, <code>t</code>, <code>g</code>, <code>c</code> and <code>n</code> to their respective complements.
We choose to keep our solution one step behind the classical reverse complement which reverses the string after the mapping.</p><p>Lastly, we will stick to lowercase characters and not deal with RNA bases for the sake of simplicity.</p><p>Here&rsquo;s what the mapping would look like:</p><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>Input</td><td>a</td><td>t</td><td>c</td><td>g</td><td>n</td></tr><tr><td>Output</td><td>t</td><td>a</td><td>g</td><td>c</td><td>n</td></tr></tbody></table><h2 id=kicking-the-tires>Kicking the tires</h2><p>Let us first note that we can&rsquo;t just use the value <code>a</code>, <code>t</code>, <code>c</code>, etc. as inputs to a function. We must convert them
to a numerical representation.</p><p>Although we might be tempted to use a given character&rsquo;s position in the alphabet,
we should prefer using the ASCII character representations since a computer will be used to churn this magic function eventually.</p><p>We can easily get the ASCII representations in python as the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>print(tuple(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;atcgn&#39;</span>))
</span></span></code></pre></div><p>which gives us <code>(97, 116, 99, 103, 110)</code></p><p>Now, let&rsquo;s examine the different ways we can approach the problem.</p><h2 id=matrices-and-polynomials>Matrices and polynomials</h2><p>The crux of this method relies on the existence of a vector <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="bold">v</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\mathbf{v}}</annotation></semantics></math></span> such that for each input character <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span>
and the complement <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span>,</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mover accent="true"><mi mathvariant="bold">v</mi><mo>⃗</mo></mover><mo>⋅</mo><mo stretchy="false">(</mo><msup><mi>p</mi><mn>4</mn></msup><mo separator="true">,</mo><msup><mi>p</mi><mn>3</mn></msup><mo separator="true">,</mo><msup><mi>p</mi><mn>2</mn></msup><mo separator="true">,</mo><msup><mi>p</mi><mn>1</mn></msup><mo separator="true">,</mo><msup><mi>p</mi><mn>0</mn></msup><mo stretchy="false">)</mo><mo>=</mo><mi>q</mi></mrow><annotation encoding="application/x-tex"> \vec{\mathbf{v}} \cdot (p^4, p^3, p^2, p^1, p^0) = q </annotation></semantics></math></span><p>Consider the input character &lsquo;a&rsquo; and the corresponding output &rsquo;t&rsquo;.
We substitute p and q in the previous expression with the ASCII values 97 and 116 respectively to get
the following polynomial.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>97</mn><mn>4</mn></msup><msub><mi>x</mi><mn>4</mn></msub><mo>+</mo><msup><mn>97</mn><mn>3</mn></msup><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><msup><mn>97</mn><mn>2</mn></msup><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msup><mn>97</mn><mn>1</mn></msup><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msup><mn>97</mn><mn>0</mn></msup><msub><mi>x</mi><mn>0</mn></msub><mo>=</mo><mn>116</mn></mrow><annotation encoding="application/x-tex"> 97^4x_{4} + 97^3x_{3} + 97^2x_{2} + 97^1x_{1} + 97^0x_{0} = 116 </annotation></semantics></math></span><p>We can setup a system of polynomials for the remaining mappings in the same way.
This gives us 5 equations, which is precisely why we chose 5 coefficients in <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi mathvariant="bold">v</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\mathbf{v}}</annotation></semantics></math></span>.</p><p>If we had more equations than unknowns, we would have been redundant. Whereas,
more unknowns than equations yields infinitely many solutions.</p><p>Here&rsquo;s one more example for <code>c</code> at 99, mapping to <code>g</code> at 103.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msup><mn>99</mn><mn>4</mn></msup><msub><mi>x</mi><mn>4</mn></msub><mo>+</mo><msup><mn>99</mn><mn>3</mn></msup><msub><mi>x</mi><mn>3</mn></msub><mo>+</mo><msup><mn>99</mn><mn>2</mn></msup><msub><mi>x</mi><mn>2</mn></msub><mo>+</mo><msup><mn>99</mn><mn>1</mn></msup><msub><mi>x</mi><mn>1</mn></msub><mo>+</mo><msup><mn>99</mn><mn>0</mn></msup><msub><mi>x</mi><mn>0</mn></msub><mo>=</mo><mn>103</mn></mrow><annotation encoding="application/x-tex"> 99^4x_{4} + 99^3x_{3} + 99^2x_{2} + 99^1x_{1} + 99^0x_{0} = 103 </annotation></semantics></math></span><p>In general, we have a matrix representing a linear map from <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">R</mi><mn>5</mn></msup></mrow><annotation encoding="application/x-tex"> \mathbf{R}^5 </annotation></semantics></math></span> to <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="bold">R</mi><mn>5</mn></msup></mrow><annotation encoding="application/x-tex"> \mathbf{R}^5 </annotation></semantics></math></span>.</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center center center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>97</mn><mn>4</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>97</mn><mn>3</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>97</mn><mn>2</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>97</mn><mn>1</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>97</mn><mn>0</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>116</mn><mn>4</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>116</mn><mn>3</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>116</mn><mn>2</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>116</mn><mn>1</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>116</mn><mn>0</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>99</mn><mn>4</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>99</mn><mn>3</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>99</mn><mn>2</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>99</mn><mn>1</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>99</mn><mn>0</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>103</mn><mn>4</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>103</mn><mn>3</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>103</mn><mn>2</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>103</mn><mn>1</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>103</mn><mn>0</mn></msup></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>110</mn><mn>4</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>110</mn><mn>3</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>110</mn><mn>2</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>110</mn><mn>1</mn></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msup><mn>110</mn><mn>0</mn></msup></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mn>4</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mn>3</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mn>2</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mn>1</mn></msub></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>x</mi><mn>0</mn></msub></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.16em" columnalign="center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>116</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>97</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>103</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>99</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>110</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">
\begin{bmatrix}
97^4 &amp; 97^3 &amp; 97^2 &amp; 97^1 &amp; 97^0\\
116^4 &amp; 116^3 &amp; 116^2 &amp; 116^1 &amp; 116^0\\
99^4 &amp; 99^3 &amp; 99^2 &amp; 99^1 &amp; 99^0\\
103^4 &amp; 103^3 &amp; 103^2 &amp; 103^1 &amp; 103^0\\
110^4 &amp; 110^3 &amp; 110^2 &amp; 110^1 &amp; 110^0\\
\end{bmatrix}
\begin{bmatrix}
x_4 \\
x_3 \\
x_2 \\
x_1 \\
x_0
\end{bmatrix} =
\begin{bmatrix}
116 \\
97 \\
103 \\
99 \\
110
\end{bmatrix}
</annotation></semantics></math></span><p>Also observe that a linear map would allow us to shift the inputs by some offset and guarantee that the output is also shifted by the same offset.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> sympy <span style=color:#f92672>import</span> Matrix
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>mappings <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;a&#39;</span>: <span style=color:#e6db74>&#39;t&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;t&#39;</span>: <span style=color:#e6db74>&#39;a&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;g&#39;</span>: <span style=color:#e6db74>&#39;c&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;c&#39;</span>: <span style=color:#e6db74>&#39;g&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#39;n&#39;</span>: <span style=color:#e6db74>&#39;n&#39;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bases <span style=color:#f92672>=</span> tuple(mappings<span style=color:#f92672>.</span>keys())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> n <span style=color:#f92672>in</span> range(<span style=color:#f92672>-</span><span style=color:#ae81ff>1000</span>, <span style=color:#ae81ff>1000</span>):
</span></span><span style=display:flex><span>    mat <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> dna_base <span style=color:#f92672>in</span> bases:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        dna_base_n <span style=color:#f92672>=</span> ord(dna_base) <span style=color:#f92672>-</span> n
</span></span><span style=display:flex><span>        dna_compl <span style=color:#f92672>=</span> mappings[dna_base]
</span></span><span style=display:flex><span>        dna_compl_n <span style=color:#f92672>=</span> ord(dna_compl) <span style=color:#f92672>-</span> n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        row <span style=color:#f92672>=</span> [dna_base_n <span style=color:#f92672>**</span> i <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(bases))]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        row<span style=color:#f92672>.</span>append(dna_compl_n)
</span></span><span style=display:flex><span>        mat<span style=color:#f92672>.</span>append(row)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    coeffs <span style=color:#f92672>=</span> Matrix(mat)<span style=color:#f92672>.</span>rref()[<span style=color:#ae81ff>0</span>][:, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>in</span> coeffs:
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>n<span style=color:#e6db74>}</span><span style=color:#e6db74> -&gt; </span><span style=color:#e6db74>{</span>coeffs<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span></code></pre></div><p>We prioritize coefficients that contain zeros since they allow us to ignore a term in the resulting polynomial.</p><p>Running the experiment yields a single polynomial where one of the coefficients is 0.</p><pre tabindex=0><code>110 -&gt; Matrix([[0], [16075/51051], [-72265/204204], [-1721/102102], [235/204204]])
</code></pre><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>compl</span>(x: str) <span style=color:#f92672>-&gt;</span> str:
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> ord(x) <span style=color:#f92672>-</span> <span style=color:#ae81ff>110</span>
</span></span><span style=display:flex><span>    c <span style=color:#f92672>=</span> (<span style=color:#ae81ff>64300</span> <span style=color:#f92672>*</span> x <span style=color:#f92672>-</span><span style=color:#ae81ff>72265</span> <span style=color:#f92672>*</span> x<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>3442</span> <span style=color:#f92672>*</span> x<span style=color:#f92672>**</span><span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>235</span> <span style=color:#f92672>*</span> x<span style=color:#f92672>**</span><span style=color:#ae81ff>4</span>)<span style=color:#f92672>//</span><span style=color:#ae81ff>204204</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>110</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> chr(c)
</span></span></code></pre></div><h2 id=modular-arithmetic>Modular arithmetic</h2><p>In this approach, a given base <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span> maps to its complement <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi></mrow><annotation encoding="application/x-tex">v</annotation></semantics></math></span> as</p><span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>v</mi><mo>=</mo><mi>K</mi><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>u</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
v = K \pmod{u}
</annotation></semantics></math></span><p>where <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span> is some known constant.</p><p>We are essentially trying to mend our problem into a Chinese remainder theorem problem. However, all moduli in a CRT problem
must be coprime. The numerical representations of our bases <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>u</mi><mo>⃗</mo></mover><mo>=</mo><mo stretchy="false">(</mo><mn>97</mn><mo separator="true">,</mo><mn>116</mn><mo separator="true">,</mo><mn>99</mn><mo separator="true">,</mo><mn>103</mn><mo separator="true">,</mo><mn>110</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\vec{u} = (97, 116, 99, 103, 110)</annotation></semantics></math></span> aren&rsquo;t quite coprime.</p><p>To deal with this, we double all the entries and add an odd number.
More abstractly, for every <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span>, <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>u</mi></mrow><annotation encoding="application/x-tex">2u</annotation></semantics></math></span> must be even. Adding an odd number <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span>, then, must make <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>u</mi><mo>+</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">2u+h</annotation></semantics></math></span> odd.</p><p>Varying this <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span> can potentially yield some <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mover accent="true"><mi>u</mi><mo>⃗</mo></mover><mo>+</mo><mi>h</mi></mrow><annotation encoding="application/x-tex">2\vec{u} + h</annotation></semantics></math></span> whose elements are coprime.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-py data-lang=py><span style=display:flex><span><span style=color:#f92672>from</span> itertools <span style=color:#f92672>import</span> starmap, permutations
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>egcd</span>(a, b):
</span></span><span style=display:flex><span>    old_r, r <span style=color:#f92672>=</span> a, b
</span></span><span style=display:flex><span>    old_s, s <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> r <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        quo <span style=color:#f92672>=</span> old_r <span style=color:#f92672>//</span> r
</span></span><span style=display:flex><span>        old_r, r <span style=color:#f92672>=</span> r, old_r <span style=color:#f92672>%</span> r
</span></span><span style=display:flex><span>        old_s, s <span style=color:#f92672>=</span> s, old_s <span style=color:#f92672>-</span> quo <span style=color:#f92672>*</span> s
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (old_r, old_s)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>gcd</span>(a, b):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> egcd(a, b)[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>are_coprime</span>(a, b):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> gcd(a, b) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>modinv</span>(a, b):
</span></span><span style=display:flex><span>    old_r, old_s <span style=color:#f92672>=</span> egcd(a, b)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> old_r <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>ValueError</span>(<span style=color:#e6db74>&#34;modular multiplicative inverse is not possible&#34;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> old_s <span style=color:#f92672>%</span> b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>are_pairwise_coprime</span>(vs):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> all(starmap(are_coprime, permutations(vs, <span style=color:#ae81ff>2</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>u <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(tuple(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;atgcn&#34;</span>))
</span></span><span style=display:flex><span>compl <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(tuple(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#34;tacgn&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># smallest target, i.e., a</span>
</span></span><span style=display:flex><span>min_of_seq <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>min(compl)
</span></span><span style=display:flex><span>compl <span style=color:#f92672>-=</span> min_of_seq
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># the largest value of the complement must be a principal value in (mod N)</span>
</span></span><span style=display:flex><span>ring_enclose <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>max(compl)
</span></span><span style=display:flex><span>ring_enclose <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>-</span> ring_enclose <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>u<span style=color:#e6db74>}</span><span style=color:#e6db74> maps to </span><span style=color:#e6db74>{</span>compl<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>min_answer <span style=color:#f92672>=</span> float(<span style=color:#e6db74>&#39;Infinity&#39;</span>)
</span></span><span style=display:flex><span>min_ih <span style=color:#f92672>=</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>32</span>):
</span></span><span style=display:flex><span>    <span style=color:#75715e># -2 * i * min_of_seq so that `vs` is as small as possible</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># + field_should_enclose so that `vs` is atleast positive and</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># greater than the largest element of `seq`</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> h <span style=color:#f92672>in</span> range(<span style=color:#f92672>-</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>*</span> min_of_seq <span style=color:#f92672>+</span> ring_enclose, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>):
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># The linear transform 2iu + h</span>
</span></span><span style=display:flex><span>        vs <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>*</span> i <span style=color:#f92672>*</span> u <span style=color:#f92672>+</span> h
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> are_pairwise_coprime(vs):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># apply chinese remainder theorem</span>
</span></span><span style=display:flex><span>        pi_n <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>prod(vs)
</span></span><span style=display:flex><span>        pi_all_but_ni <span style=color:#f92672>=</span> pi_n <span style=color:#f92672>/</span> vs
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>            modinv_ni <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(tuple(starmap(modinv, zip(pi_all_but_ni, vs))))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>ValueError</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        pieces <span style=color:#f92672>=</span> pi_all_but_ni <span style=color:#f92672>*</span> compl <span style=color:#f92672>*</span> modinv_ni
</span></span><span style=display:flex><span>        answer <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>sum(pieces) <span style=color:#f92672>%</span> pi_n
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> answer <span style=color:#f92672>&lt;</span> min_answer:
</span></span><span style=display:flex><span>            min_answer <span style=color:#f92672>=</span> answer
</span></span><span style=display:flex><span>            min_ih <span style=color:#f92672>=</span> (i, h)
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;progress: </span><span style=color:#e6db74>{</span>min_ih<span style=color:#e6db74>}</span><span style=color:#e6db74> -&gt; </span><span style=color:#e6db74>{</span>int(min_answer)<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>min_answer <span style=color:#f92672>=</span> int(min_answer)
</span></span><span style=display:flex><span>print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>{</span>min_ih<span style=color:#e6db74>}</span><span style=color:#e6db74> -&gt; </span><span style=color:#e6db74>{</span>min_answer<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span></code></pre></div><p>We set the upper limit of our experiment as 32 to avoid waiting too long
for a reasonable answer.</p><pre tabindex=0><code>[ 97 116 103  99 110] maps to [19  0  2  6 13]
progress: (1, -159) -&gt; 47922894
progress: (3, -559) -&gt; 33253051
(3, -559) -&gt; 33253051
</code></pre><p>With the final solution, we can cook up the following function. Note how we add 97 since we had shifted <span class=katex><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover accent="true"><mi>v</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{v}</annotation></semantics></math></span>
such that its smallest element was 0.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> base <span style=color:#f92672>in</span> <span style=color:#e6db74>&#39;atgcn&#39;</span>:
</span></span><span style=display:flex><span>    compl <span style=color:#f92672>=</span> chr(<span style=color:#ae81ff>97</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>33253051</span> <span style=color:#f92672>%</span> (<span style=color:#ae81ff>6</span><span style=color:#f92672>*</span>ord(base)<span style=color:#f92672>-</span><span style=color:#ae81ff>559</span>))
</span></span><span style=display:flex><span>    print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>{</span>base<span style=color:#e6db74>}</span><span style=color:#e6db74> -&gt; </span><span style=color:#e6db74>{</span>compl<span style=color:#e6db74>}</span><span style=color:#e6db74>&#39;</span>)
</span></span></code></pre></div><h2 id=wrapping-up>Wrapping up</h2><p>Those were two ways I could think of mapping DNA nucleobases to their complements. Although this is a contrived example,
it was a fun exercise and the modular arithmetic approach is my personal favorite. Let me know how you would have solved
this differently by shooting me an email!</p><p>Bye now.</p></section></article><footer class=post-tags data-pagefind-meta=tags><a href=https://lavafroth.is-a.dev/tags/dna class=list-tag>DNA</a>
<a href=https://lavafroth.is-a.dev/tags/bioinformatics class=list-tag>Bioinformatics</a>
<a href=https://lavafroth.is-a.dev/tags/linear-algebra class=list-tag>Linear Algebra</a>
<a href=https://lavafroth.is-a.dev/tags/remainder-theorem class=list-tag>Remainder Theorem</a></footer><nav class=post-nav><a class=prev href=https://lavafroth.is-a.dev/post/do-you-really-need-a-copilot/><span>←</span><span>Need a hand?</span></a>
<a class=next href=https://lavafroth.is-a.dev/post/project-mana-demo/><span>Building an in-browser Manim clone</span><span>→</span></a></nav></main><footer class=footer><p>&copy; 2025 <a href=https://lavafroth.is-a.dev/>lavafroth</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/issues/new/choose>Report an issue</a></p><p><a href=https://github.com/lavafroth/lavafroth.github.io/discussions/>Discuss</a></p><p><a href=https://lavafroth.is-a.dev/privacy>Privacy</a></p><p><a href=https://creativecommons.org/licenses/by-sa/4.0/legalcode>License</a></p></footer></body></html>